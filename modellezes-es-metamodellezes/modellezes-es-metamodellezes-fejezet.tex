\topic{Modellezés és metamodellezés}

\graphicspath{ {./modellezes-es-metamodellezes/figures/} }

Ebben a fejezetben a modellezés alapfogalmaival fogunk megismerkedni. Az itt bevezetett fogalmak újra és újra megjelennek majd a későbbi fejezetekben, ahol részletesen ki fogunk térni az adott területen történő értelmezésükre.

%Az alábbi dokumentum a rendszermodellezés tárgy első előadásához kapcsolódó segédanyag, mely tartalmazza az elhangzott definíciókat és a hozzájuk tartozó egyszerűbb magyarázatokat.

\section{Modellezés}

Mi értelme van modellezni? Fejben szinte mindig modellezünk, bármilyen probléma kerül elénk. Nincs ez másképp egy szoftver fejlesztésekor sem. Lássuk hát, miről beszélünk, amikor a modell szót használjuk.
% Legfőbb szerepe a kommunikáció:

\begin{definicio}
	\Fogalom{modell}: egy valós vagy hipotetikus világ (a ,,\fogalom{rendszer}'') egy részének egyszerűsített képe, amely a rendszert helyettesíti bizonyos megfontolásokban. Egy modell elkészítésének mindig egy kérdés megválaszolása a célja.
\end{definicio}

A modell tehát egy többnyire bonyolult rendszer egyszerűsített reprezentációja, amiben csak az aktuális probléma szempontjából lényeges vonásokat szerepeltetjük.
Egy adott rendszer modellé történő leképezésének általában két fontos előnye van: %\emph{áttekinthetőbb}, \emph{kisebb (véges)}.

\begin{itemize}
	\item A modell az eredeti rendszernél \emph{kisebb}, hiszen az aktuális problémához nem (vagy lazábban) kapcsolódó, elhanyagolható információk nem jelennek meg benne.
	\item A modell az eredeti rendszernél \emph{áttekinthetőbb}, hiszen csak az adott probléma szempontjából érdekes, releváns információkat és kapcsolatokat kell vizsgálni.
\end{itemize}

\begin{pelda}
	Modellekre sok példát láthatunk a hétköznapokban is. Nem csak gyerekek körében népszerű játék a modellvasút. Itt valóban modellről beszélhetünk, hiszen a játékvonatok számos tekintetben hűen reprezentálják a valódi vonatokat, azonban például ``szemet hunyunk'' a méretükkel, tömegükkel, a bennük lévő villanymotor paramétereivel és még sok egyéb hasonló tulajdonságukkal kapcsolatban.

	Az informatika egyik leggazdagabb modellforrása a matematika. Amikor gráfelméletet tanulunk, valójában rengeteg, bizonyos szempontból hasonló probléma közös modelljét vizsgáljuk. Valóban, a matematika egyik célja az ilyen modellek azonosítása és minél hatékonyabb eszköztárak kidolgozása a rajtuk megfogalmazott feladatok megoldására. A gráfoknál maradva (gráfokról bővebben \iflabeldef{sec:graf}{\aref{sec:graf}.~szakaszban}{a \emph{Struktúra alapú modellezés} c. segédanyagban} és a \bszketto c. tárgyban lehet tájékozódni) egy város úthálózata jól reprezentálható egy élsúlyokkal ellátott gráffal, ahol a csomópontok a kereszteződések, az élek az útszakaszok, az élsúlyok pedig a szakaszok hosszait jelölik. Ez a modell kiválóan alkalmas legrövidebb útvonalak tervezésére (mi kellene még a \emph{leggyorsabb} útvonal tervezéséhez?), de figyelmen kívül hagy számos egyéb paramétert, például az utakon lévő kanyarulatokat, a legnagyobb megengedett sebességet stb.
\end{pelda}

\begin{megjegyzes}
	Az, hogy a modell kisebb, nem mindig ``kényelmi'' szempont. Gyakran lehet olyan problémával találkozni, aminek a mérete bizonyos szempontból \fogalom{vegtelen} (például végtelen sok állapota van, folytonos változók vannak benne, esetleg részét képezi az \emph{idő}), viszont egy alkalmas \fogalom{veges} modellen a számunkra releváns tulajdonságok továbbra is jól vizsgálhatók maradnak. Egy autót fizikai szempontból modellezhet a pillanatnyi sebességvektora, ami három valós szám, tehát a modellünk így végtelen. Ha viszont feltételezzük, hogy a sebesség nagysága nem lehet $200~\textrm{km/h}$-nál több, és két tizedesjegy pontossággal adjuk meg a vektor koordinátáit (tehát \emph{diszkrét értékekkel} jellemezzük a rendszert), akkor máris véges modellt kapunk. Természetesen ez a modell kicsit torzítani fog a valósághoz képest, de számos problémánál ez a hiba elhanyagolhatóan kicsi lesz (ráadásul végtelen modellen lehet, hogy nem is tudnánk megoldást adni).
\end{megjegyzes}

Fontos kérdés, hogy hogyan lehet ábrázolni egy modellt. Maga a modell ugyanis többnyire egy hipotetikus struktúra, nem kézzel fogható és nem is mindig célszerű teljes részletességgel ábrázolni.

\begin{definicio}
	\Fogalom{diagram}: a modell egy nézete, amely a modell bizonyos aspektusait grafikusan ábrázolja.
\end{definicio}

\begin{megjegyzes}
Fontos megjegyezni, hogy nem minden modell, ami modellnek látszik.

\begin{itemize}
	\item \emph{A modell nem a valóság}: az általunk definiált modellen bizonyos állítások igazak lehetnek, amik a valóságban nem állják meg a helyüket.
	\item \emph{A modell nem a diagram}: a diagram csak egy ábrázolás módja a modellnek, amivel olvashatóvá tesszük.
\end{itemize}
\end{megjegyzes}

%\todo{<első alternatíva>}
%
%\section{Modellezési nyelvek}
%
%A modellek leírásához nem elég, ha diagramokat rajzolunk. Egy modell precíz megadásához szükség van egy \fogalomragozva{modellezesi nyelv}{modellezési nyelvre}. Egy modellezési nyelv lehet \emph{szöveges} (pl. Verilog, VHDL, Java stb.) vagy \emph{grafikus} (pl. webes konyhatervező, UML diagramok stb.). Gyakori, hogy egy modell leírásához szöveges és grafikus nyelvet is használunk, ugyanis mindkettőnek megvannak a saját előnyei és hátrányai: jellemzően modellt építeni könnyebb szöveges nyelv használatával, míg a modell olvasása grafikus nyelvek (diagramok) segítségével egyszerűbb.
%
%A modellezési nyelvek legfőbb célja a kommunikáció gép-gép, ember-gép, vagy akár ember-ember között is. Egy nyelv megadásához két dolgot kell definiálni: a \emph{szintaxist} és a \emph{szemantikát}.
%
%%Segítségükkel modelleket építhetünk, amik lehetnek szöveges (pl.: Verilog, VHDL, Java stb.), vagy grafikusak is (pl.: webes konyhatervező, UML diagrammok, UPPAAL stb.). Céljuk a kommunikáció gép-gép, ember-gép vagy akár ember-ember között is. A nyelveknek két fő aspektusa van:
%
%\begin{definicio}
%	\Fogalom{szintaxis}: egy szabályrendszer, ami meghatározza, hogy a modell milyen elemekből épül fel, ezeknek mi a (szöveges vagy grafikus) reprezentációja, és a különböző elemek milyen módon kombinálhatók.
%\end{definicio}
%
%\begin{definicio}
%	\Fogalom{szemantika}: a szintaxis által megadott nyelvi elemek jelentését definiáló szabályrendszer.
%\end{definicio}
%
%%\begin{itemize}
%%	\item \fogalom{szintaxis}: hogyan írom a le a modellt? Egy szabályrendszer, ami meghatározza, hogy a nyelv milyen elemekből épül fel és azok hogyan kombinálhatóak.
%%	\item \fogalom{szemantika}: mit jelent a modell? A szintaxis által definált nyelvi elemek jelentését definiáló szabályrendszer.
%%\end{itemize}
%
%A szintaxis tehát definiálja, hogy hogyan írhatjuk le a modellt az adott nyelv segítségével, a szemantika pedig megadja, hogy az így leírt modell pontosan mit jelent.
%
%\begin{pelda}
%	A C nyelv egy szöveges nyelv, melyben elemeknek tekinthetjük az \code{if}, \code{for}, \code{switch}, \code{változónevek}, \code{metódusnevek}, \code{típusok} stb. részeket. Ezek azonban nem tetszőleges sorrendben állhatnak egymás mellett, hanem egy jól meghatározott szabályrendszer szerint. Ez a szintaxis. Azt, hogy az \code{if} kulcsszóval elágazást, a \code{for} kulcsszóval pedig egy ciklust definiálunk és nem pedig valami teljesen más dolgot, a szemantika határozza meg. Vagyis a szemantika jelentéssel tölti meg a nyelvi elemeket.
%
%	A Yakindu eszköz bizonyos szinten egy grafikus nyelvet határoz meg, ahol például nyelvi elemek a dobozok és nyilak (az állapottérképek Yakindu által definiált modellezési nyelvét \iflabeldef{sec:allapot-alapu-modellezes}{\aref{sec:allapot-alapu-modellezes}.}{az \emph{Állapot alapú modellezés}}). A szintaxis meghatározza, hogy a dobozokból csak nyilakkal lehet összekötni más dobozokat. A szemantikus jelentésük pedig az, hogy a dobozok állapotokat, a nyilak pedig állapotátmeneteket jelölnek (tehát megmutatják, hogy az alkalmazásunk melyik állapotból melyik állapotba kerülhet).
%\end{pelda}
%
%\begin{megjegyzes}
%	Szintaktikailag leírhatunk olyan kifejezéseket a nyelvben, aminek szemantikailag nincs értelme: jó példa erre a nullával osztás.
%\end{megjegyzes}
%
%
%\section{Metamodellezés}
%
%Az imént bevezetett modellezési nyelvek szerepe az volt, hogy modelljeink leírhatóak, megjeleníthetőek legyenek. Azt is mondtuk, hogy ugyanazt a modellt többféle nyelven is érdemes lehet reprezentálni. Ez viszont azt jelenti, hogy egy adott modelltípus leírására alkalmas nyelvek mögött van egy közös \emph{modell}, ami miatt alkalmasak ugyanannak az ismeretnek a kifejezésére.
%
%\begin{definicio}
%	A \fogalom{metamodell} egy modellezési nyelv modellje. Meghatározza, hogy a nyelvnek milyen típusú elemei vannak, milyen kapcsolatban állhatnak egymással, és a típusoknak mi a viszonya egymáshoz.
%\end{definicio}
%
%A metamodell tehát modellezési nyelveket modellez, a konkrét jelölölésrendszer elhanyagolásával. A metamodellt emiatt szokás \fogalomragozva{absztrakt szintaxis}{absztrakt szintaxisnak} is nevezni, míg a korábbiakban definiált szintaxisra ilyenkor \fogalomragozva{konkret szintaxis}{konkrét szintaxisként} szokás hivatkozni. Ezzel a terminológiával élve egy modellezési formalizmust az absztrakt szintaxisával (más néven egy metamodellel), egy vagy több konkrét szintaxissal (szöveges vagy grafikus jelölésrendszer a metamodell elemeihez) és a szemantikával adhatunk meg.
%
%\begin{pelda}
%	Modellekre és metamodellekre számos példa kerül majd elő a későbbi tanulmányok során:
%	\begin{itemize}
%		%\item Egyed-kapcsolat, EK modell (entity-relationship, ER)
%		\item AZ UML~\cite{UML} (Unified Modeling Language) objektum diagramján ábrázolt objektummodelleket az osztálydiagramokon ábrázolt metamodelljeik szerint adhatjuk meg.
%		\item Egy adatbázis tábla metamodellje a relációs adatbázisséma.
%		\item Az XML dokumentumok metamodelljét az XML sémák adják.
%	\end{itemize}
%	A konkrét szintaxist (jelölésrendszert) mindegyik esetben külön határozzák meg, az UML esetében többféle grafikus és szöveges szintaxis is definiált.
%\end{pelda}
%
%\begin{tipp}
%	Minden fejezetben, ahol modellezési formalizmusokkal ismerkedünk meg, szerepelni fog az adott adott modelltípus metamodellje is.
%\end{tipp}
%
%\todo{</első alternatíva>}
%\todo{<második alternatíva>}

\section{Modellezési nyelvek}

A modellek leírásához nem elég, ha diagramokat rajzolunk. Egy modell precíz megadásához szükség van egy \fogalomragozva{modellezesi nyelv}{modellezési nyelvre}. A modellezési nyelvek legfőbb célja a kommunikáció gép-gép, ember-gép, vagy akár ember-ember között is. Egy modellezési nyelv lehet \emph{szöveges} (pl. Verilog, VHDL, Java stb.) vagy \emph{grafikus} (pl. webes konyhatervező, UML diagramok stb.). Gyakori, hogy egy modellezési nyelv szöveges és grafikus jelölésrendszert is definiál, ugyanis mindkettőnek megvannak a saját előnyei és hátrányai: jellemzően modellt építeni könnyebb szöveges nyelv használatával, míg a modell olvasása grafikus nyelvek (diagramok) segítségével egyszerűbb.

\begin{definicio}
	Egy \fogalom{modellezesi nyelv} négy részből áll:
	\begin{itemize}
		\item \Fogalom{absztrakt szintaxis} (más néven \fogalom{metamodell}): meghatározza, hogy a nyelvnek milyen típusú elemei vannak, az elemek milyen kapcsolatban állhatnak egymással, és a típusoknak mi a viszonya egymáshoz. Ezt a reprezentációt használják gépek a modell belső tárolására.
		\item \Fogalom{konkret szintaxis}: az absztrakt szintaxis által definiált elemtípusokhoz és kapcsolatokhoz szöveges vagy grafikus jelölésrendszert definiál. Ezt a reprezentációt használják az emberek a modell olvasására és szerkesztésére.
		\item \Fogalom{jolformaltsagi kenyszer}: Megadja, hogy egy érvényes modellnek milyen egyéb követelményeknek kell megfelelnie.
		\item \Fogalom{szemantika}: az absztrakt szintaxis által megadott nyelvi elemek jelentését definiáló szabályrendszer.
	\end{itemize}
	Egy modellezési nyelvhez több konkrét szintaxis is adható.
\end{definicio}

Az absztrakt szintaxis tekinthető a modellezési nyelv modelljének, ezért hívjuk \emph{metamodellnek} is. A konkrét szintaxis a metamodellhez képest annyival több, hogy a definiált elemekhez megjeleníthető reprezentációkat rendel, ezáltal válik olvashatóvá és szerkeszthetővé egy modell leírása. Ha nem okoz félreértést, akkor a szintaxis szót leggyakrabban az absztrakt és konkrét szintaxis együttes jelölésére használjuk (tehát az elemkészletre és a jelölésekre együtt). A jólformáltsági kényszerek tovább szűkítik a lehetséges modellek körét olyan szabályokkal, mint például az azonos nevű elemek tiltása. Végül a szemantika megadja, hogy az így leírt modell pontosan mit is jelent, vagy hogyan ``működik''. A szemantika fogalmát strukturális és viselkedési modellek esetén kissé eltérően értelmezzük majd, erre a későbbi fejezetekben térünk vissza.

\begin{pelda}
	A C nyelv egy szöveges nyelv, melyben elemeknek tekinthetjük az \code{if}, \code{for}, \code{switch}, \code{változónevek}, \code{metódusnevek}, \code{típusok} stb. részeket. Ezek azonban nem tetszőleges sorrendben állhatnak egymás mellett, hanem egy jól meghatározott szabályrendszer szerint. Ez a szintaxis. Azt, hogy az \code{if} kulcsszóval elágazást, a \code{for} kulcsszóval pedig egy ciklust definiálunk és nem pedig valami teljesen más dolgot, a szemantika határozza meg. Vagyis a szemantika jelentéssel tölti meg a nyelvi elemeket.
\end{pelda}

\begin{pelda}
	A Yakindu Statechart Tools\footnote{\url{http://statecharts.org}} egy állapotgépek specifikálását és fejlesztését lehetővé tévő nyílt forráskódú eszköz, mely az Eclipse IDE alapjaira épül. Kényelmi funkcióihoz tartozik az elkészített modell validációja, szimulálásának lehetősége, ill. a modellalapú kódgenerálás is. A szöveges (XML) nyelv mellett egy könnyen használható grafikus felületet is biztosít, ahol lehetőségünk van állapotokat és átmeneteket definiálni. Ezek nyelvi elemként, mint dobozok és nyilak jelennek meg. A grafikai szintaxis meghatározza, hogy a dobozokból csak nyilakkal lehet összekötni más dobozokat. Ekkor igazából azt adjuk meg, hogy egy adott állapotból alkalmazásunk milyen másik állapotba kerülhet. Ez a szemantikai jelentés. Az állapot alapú modellek leírásával részletesen \iflabeldef{sec:allapot-alapu-modellezes}{\aref{sec:allapot-alapu-modellezes}.}{az \emph{Állapot alapú modellezés}} fejezetben fogunk foglalkozni.
\end{pelda}

\begin{megjegyzes}
	A metamodell ugyanúgy modell, mint a segítségével leírható modellek. Ebből kifolyólag ugyanúgy adható hozzá modellezési nyelv, aminek szintén lesz egy metamodellje. A gyakorlatban ez addig folytatódik, amíg az egyik metamodellt már egy szabványos modellezési nyelv segítségével írjuk fel. Érdekesség, hogy az UML metamodell-hierarchiájának gyökerében egy \emph{önleíró modell} található: önmaga a saját metamodellje is egyben.
\end{megjegyzes}

\begin{pelda}
	Modellekre és metamodellekre számos példa kerül majd elő a későbbi tanulmányok során:
	\begin{itemize}
		%\item Egyed-kapcsolat, EK modell (entity-relationship, ER)
		\item Az \rovidites{UML}~\cite{UML} objektum diagramján ábrázolt objektummodelleket az osztálydiagramokon ábrázolt metamodelljeik szerint adhatjuk meg.
		\item Az \rovidites{XML} dokumentumok metamodelljét az XML sémák adják.
		\item Egy adatbázis tábla metamodellje a relációs adatbázisséma.
	\end{itemize}
	A konkrét szintaxist (jelölésrendszert) mindegyik esetben külön határozzák meg, az UML esetében többféle grafikus és szöveges szintaxis is definiált.
\end{pelda}

\begin{tipp}
	Minden fejezetben, ahol modellezési formalizmusokkal ismerkedünk meg, szerepelni fog az adott modelltípus metamodellje is.
\end{tipp}

%\todo{</második alternatíva>}

\section{Nyílt és zárt világ feltételezés} \label{sec:owacwa}

Egy modell szemantikájának definiálása során több feltételezésből is kiindulhatunk. Ezeket rögzíteni kell, és a modell értelmezésekor döntő szerepük van a különböző állítások igazságtartalmának eldöntésekor.

\begin{definicio}
	\Fogalom{zart-vilag-feltetelezes}: Minden állítás, amiről nem ismert, hogy igaz, hamis.
\end{definicio}

\begin{definicio}
	\Fogalom{nyilt-vilag-feltetelezes}: Egy állítás annak ellenére is lehet igaz, hogy ez a tény nem ismert.
\end{definicio}

A két feltételezés között az egyik legfontosabb különbség, hogy a nyílt világ feltételezés elismeri és használja az \emph{ismeretlen} fogalmát, míg a zárt világban minden tudás ismertnek tekintett. Mindkét feltételezésnek megvan a maga szerepe és helye, ahogy azt a következő két példa is illusztrálja.

\begin{pelda}
	A zárt világ feltételezést olyankor alkalmazzuk, amikor egy rendszernek a teljes szükséges információ a rendelkezésére áll. Erre példa egy tömegközlekedési adatbázis: ha megkérdezzük, hogy közlekedik-e közvetlen járat a Magyar Tudósok körútja és a Gellért tér között, és ilyen járat nincs az adatbázisban, akkor a válasz egyértelmű ``nem''. Ebben az esetben valóban ez az elvárt és helyes válasz.

	A nyílt világ szemantika olyankor alkalmazandó, amikor nem feltételezhetjük, hogy minden információ a rendelkezésünkre áll. Például egy orvosi nyilvántartó rendszerben előfordulhat (sőt, számítani kell rá), hogy egy beteg annak ellenére allergiás valamire, hogy ez a nyilvántartásban nem szerepel.
\end{pelda}

\section{Absztrakció és finomítás}

A modell definíciójának szerves része az \emph{egyszerűsítés}, az adott probléma szempontjából irreleváns információk elhanyagolása. Ugyanannak a rendszernek több modelljét is elkészíthetjük más-más részletek kihagyásával. Ráadásul egy elkészített modellből további részleteket hagyhatunk el, vagy éppen újabb részleteket vehetünk bele, így a modellek a részletgazdagság szerint egyfajta hierarchiába rendezhetők.

Különbséget kell tennünk azonban egy modell részletekkel gazdagítása és megváltoztatása között. Ehhez segít, ha megkülönböztetjük a modellt (illetve a modellezett rendszert) és a környezetét.

\begin{definicio}
	\Fogalom{rendszer} és \fogalomragozva{kornyezet}{környezete}: a környezet (vagy kontextus) a rendszerre ható tényezők összessége. Modellezéskor a modellezett rendszernek mindig egyértelműen definiálni kell a \emph{határait}. A határon belül eső dolgokat a rendszer részének tekintjük, az azon kívül esők adják a környezetet. Szokás még a környezet elemeit két csoportba sorolni: \emph{releváns} környezeti elemek azok a dolgok, amik a rendszerrel közvetve vagy közvetett módon kapcsolatban állnak, míg \emph{irreleváns} környezeti elem, ami a rendszerrel nincs kapcsolatban.
\end{definicio}

\begin{megjegyzes}
	Gyakori, hogy egy rendszer környezetéről (is) készítünk modelleket. Ennek haszna a rendszer és a környezet interakcióinak pontosabb megértése, tervezése és analízise. Az elkészült rendszerek tesztelésekor például gyakran nem az éles környezetben tesztelünk, hanem a környezet modellje alapján szimuláljuk az interakciókat.

	A környezet szempontjából nézve a rendszert tekinthetjük \fogalomragozva{fekete doboz}{fekete doboznak} vagy \fogalomragozva{feher doboz}{fehér doboznak}. Előbbi esetben a rendszer belső felépítését és viselkedését nem ismerjük, míg utóbbi esetben ezek az információk rendelkezésre állnak. Ez a két fogalom főleg tesztek tervezésekor érdekes, erről bővebben \iflabeldef{sec:modellek-ellenorzese}{\aref{sec:modellek-ellenorzese}.~fejezetben}{a \emph{Modellek ellenőrzése}} fejezetben lesz szó.
\end{megjegyzes}

\begin{pelda}
	Sportautók tervezésekor a rendszer jól körülhatárolható. Aerodinamikai szempontból releváns külvilágnak tekinthető az autó körül áramló levegő. Tervezéskor célszerű a karosszéria (rendszer) és a légáramlás (környezet) modelljét is elkészíteni, hogy minél pontosabb szimulációkkal megfelelő jóslatokat tudjunk tenni a terv minőségét illetően. Később, amikor az elkészült prototípus tesztelése folyik, a szélcsatorna tekinthető a légáramlás egy pontosabb, fizikai modelljének.
\end{pelda}

A környezet segítségével definiálhatjuk, hogy mit jelent a modell részletekkel gazdagítása.

\begin{definicio}
	\Fogalom{finomitas}: a modell olyan részletezése (pontosítása), hogy a környezet szempontjából nézve a finomított modell (valamilyen tekintetben) helyettesíteni tudja az eredeti modellt.
\end{definicio}

A finomítás mindig többletismeret bevitelét jelenti a modellbe. A finomítás konkrét módja és a helyettesíthetőség pontos definíciója problémafüggő, amikre sok példát láthatunk majd a későbbi fejezetekben. Természetesen a finomításnak ellentétes művelete is van.

\begin{definicio}
	\Fogalom{absztrakcio}: a finomítás inverz művelete, vagyis a modell részletezettségének csökkentése, a modellezett ismeretek egyszerűsítése.
\end{definicio}

A szabályos finomítás után az eredeti modell mindig visszakapható egy szabályos absztrakcióval. Érdemes megjegyezni, hogy finomítás során többnyire tervezői döntést hozunk annak tekintetében, hogy egy adott részletet hogyan illesztünk a modellbe, míg az absztrakció során a részlet elhagyása egyértelmű. Következésképpen egy finomítási lépésnek általában sokféle eredménye lehet, de egy adott absztrakciós lépésnek mindig csak egy.

\begin{pelda}
	Egy közlekedési lámpának megadható egy absztrakt és egy részletes modellje is. Az absztrakt modellben a lámpának két állása van: \emph{tilos} és \emph{szabad}. A részletesebb modellben a \emph{szabad} állapotnak megfelelhet a \emph{zöld} állapot, a \emph{tilos} állapotban pedig a \emph{sárga}, \emph{piros} és \emph{piros-sárga}.

	Figyeljük meg, hogy az absztrakt modellből a részletesebbe lépés (finomítás) során többlet ismeretet vittünk a modellbe, mégpedig a lámpákkal kapcsolatban. Ráadásul mivel az új állapotok mindegyike egyértelműen megfeleltethető egy réginek, a környezet számára a rendszer továbbra is leírható az absztrakt modellel.

	Azt is láthatjuk, hogy a finomítási lépésnek (``bontsuk szét a \emph{tilos} állapotot'') több megoldása is lehetett volna, míg az ennek megfelelő absztrakciós lépésnek (``vonjuk össze a \emph{sárga}, \emph{piros} és \emph{piros-sárga} állapotokat'') csak egyetlen megoldása van (az elnevezésektől eltekintve).
\end{pelda}

\begin{tipp}
	A későbbi fejezetekben az adott témakör vonatkozásában számos példát adunk majd absztrakcióra és finomításra.
\end{tipp}
