% !TeX spellcheck = hu_HU
\topic{Folyamatmodellezés}

\graphicspath{ {./folyamatmodellezes/figures/} }

\lstset{
	language=c,
	morekeywords={sync}
}

\newcommand{\folyamatmodellscale}{0.42}
\newcommand{\balhasab}{0.4\linewidth}
\newcommand{\jobbhasab}{0.6\linewidth}

% diasorok:
% - https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/bsc-t%C3%A1rgyak/rendszermodellez%C3%A9s/15/04-folyamatmodellezes.pdf
% - https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/bsc-t%C3%A1rgyak/rendszermodellez%C3%A9s/15/05-bpmn-dfn.pdf

Az informatikában és azon kívül is számos esetben találkozunk olyan viselkedéssel, amikor megadott tevékenységek megadott sorrendben zajlanak. Például egy autómegosztó szolgáltatásban egy fuvar rendeléséhez, banki ügyintézés esetén a hitelbírálathoz, egyetemi környezetben egy tárgy felvételéhez egy jól meghatározott \fogalom{folyamat} tartozik. Amennyiben ezeket digitálisan szeretnénk végezni, fontos, hogy a folyamatokat precízen definiáljuk.

A folyamatmodelleket széleskörűen használják, többek között az informatikában rendszerek működtetésére, protokollok specifikációjára, adatelemzési folyamatok specifikálására. Látni fogjuk, hogy a szoftverek programkódjának elemzése is folyamatmodellre vezet.

\section{Folyamatok}

A \fogalomragozva{viselkedes-alapu-modellezes}{viselkedési modellek} a rendszer viselkedését többféle aspektusból jellemezhetik:

\begin{itemize}
	\item Az \fogalomragozva{allapot-alapu-modellezes}{állapot alapú modellek} esetén a rendszereket az \fogalomragozva{allapot}{állapotukkal} jellemezzük. Az állapotgép alapú viselkedésmodell arra válaszol, hogy ,,miként változhat'' a rendszer. Másként fogalmazva: a modell elsődlegesen arra összpontosít, hogy milyen állapotokban lelhető fel a rendszer (és nevekkel látja el az állapotokat), ill. milyen hatásokra mely állapotból mely állapotokba léphet át. Az másodlagosnak tekinthető, hogy ez a változás részletesebben megvizsgálva hogyan zajlik le, ezért a modell azt az egyszerűsítést alkalmazza, hogy az állapotátmenetek pillanatszerű események. Ilyen állapot alapú modellekkel bővebben  \iflabeldef{sec:allapot-alapu-modellezes}{\aref{sec:allapot-alapu-modellezes}.}{\emph{Állapot alapú modellezés}} fejezetben foglalkoztunk.
	\item Ezzel szemben a \fogalomragozva{folyamatmodell}{folyamatmodellek} fókusza az, hogy ,,mit csinál'' egy rendszer. A tevékenységeknek időbeli kiterjedést tulajdonítunk (ahelyett, hogy pillanatszerűvé egyszerűsítenénk őket), és azt vizsgáljuk, hogy mely tevékenységek végezhetőek el más tevékenységek előtt vagy után, esetleg velük átlapolódva. Ugyan a rendszer állapotainak jellemzése (adott időpontban mely tevékenységek vannak folyamatban, fejeződtek már be, stb.) implicit módon kikövetkeztethető a folyamatmodellből, de ez mintegy másodlagos; a modell a folyamatot alkotó tevékenységeknek ad nevet, és ezek viszonyának megadását várjuk el a modellezőtől.
\end{itemize}

\begin{megjegyzes}
A folyamatmodellezés történeti előzményei:

\begin{itemize}
	\item Programok vezérlési szerkezete
	\item Ütemezés (pl. GANTT diagramok): tevékenységek állapota, időzítése, és függőségei
	\item Gyártási/irodai folyamatok modellezése
	\item IDEF-0: 1980-as évek, US AirForce: logikai függőségek (adatfüggőség és végrehajtási logika nem)
	\item Logisztikai folyamatok leírása
	\item Üzemeltetés: ,,runbook''
\end{itemize}

TODO: IDEF-0 ábra

% http://ocw.mit.edu/courses/aeronautics-and-astronautics/16-885j-aircraft-systems-engineering-fall-2005/readings/sefguide_01_01.pdf
% Figure 5-7. IDEF0 Diagram Example
% http://ocw.mit.edu/terms/

\remofigscale{GanttChartAnatomy}{GANTT diagram}{0.46}

\footnote{\url{https://commons.wikimedia.org/wiki/File:GanttChartAnatomy.svg}}
\end{megjegyzes}

A folyamatmodellezés esetén a rendszerünk viselkedését egy folyamattal jellemezzük.

\begin{definicio}
	A \fogalom{folyamat} tevékenységek összessége, melyek adott rendben történő végrehajtása valamilyen célra vezet.
\end{definicio}

\section{A folyamatmodellek építőkövei}

Az alábbiakban bemutatjuk a folyamatmodellek építőköveinek nevét, grafikus jelölését és szemantikáját.


\subsection{Elemi tevékenység}

Mielőtt valódi folyamatmodelleket vizsgálnánk, először meg kell ismerkednünk azzal az esettel, amikor valamilyen viselkedés részleteit \emph{nem} modellezzük folyamatként.

\begin{pelda}
Szoftverünk C nyelvű forráskódjából futtatható programot szeretnénk előállítani; ennek egyik lépéseként egy konkrét forrásállományt le kell fordítanunk (\emph{compile}) a fordítóprogram segítségével. Mivel a fordítóprogramot nem mi készítjük, ezért nem szükséges részleteiben vizsgálnunk, hogy milyen lépésekből áll a futása. Így tehát azt mondhatjuk, hogy a fordítóprogram futása egy \fogalom{elemi-tevekenyseg}; valamikor el fog kezdődni, utána némi idővel be fog fejeződni, és nem részletezzük, hogy közben mi történik. Ebben a jegyzetben \aref{fig:szintaxis/elemi-tevekenyseg}. ábrán láthatóhoz hasonló rajzjelekkel fogjuk a hasonló elemi tevékenységeket jelölni.
\end{pelda}

\begin{definicio}
	Az \fogalom{elemi-tevekenyseg} olyan időbeli kiterjedéssel rendelkező tevékenység, amelynek a megkezdésén és befejezésén túl további részleteit nem modellezzük.
\end{definicio}

\remofigscalefixed{szintaxis/elemi-tevekenyseg}{Elemi tevékenység grafikus szintaxisa}{\folyamatmodellscale}

\begin{pelda}
Mit is értünk azalatt, hogy a fordítóprogram futtatása időbeli kiterjedéssel bír? Ahogy \aref{fig:szintaxis/elemi-tevekenyseg-ido}. ábrán látható idődiagram is illusztrálja, kezdetben a tevékenység nem fut. Valamikor a működés során eljön a tevékenység kezdete - ezt egy pillatanszerű eseményként modellezzük; utána úgy tekinthető, hogy a fordítás tevékenység \emph{folyamatban van}. Később eljön az az idő, amikor a fordítás befejeződik; ez egy újabb pillanatszerű esemény, amely után az elemi tevékenység már nincs folyamatban, befejezettnek tekinthető.
\end{pelda}

\remofigscalefixed{szintaxis/elemi-tevekenyseg-ido}{Elemi tevékenység időbeli lefutása idődiagramon}{\folyamatmodellscale}

Ahogy a fenti példa is illusztrálja, minden elemi tevékenység önmagában egy háromelemű állapotteret határoz meg: $\{$még nem kezdődött el, folyamatban van, már befejeződött$\}$; később az összetett folyamatmodellek állapotteréről is lesz szó. Látható, hogy az elemi tevékenység is leírható a korábban tanult állapotmodellezési eszköztárral; ebben az esetben viszont más a modell fókusza, más elemeket tartunk elnevezésre és vizsgálatra érdemesnek.

\begin{megjegyzes}
	Bizonyos források \fogalom{atomi} tevékenység vagy lépés néven hivatkoznak ugyanerre az \fogalom{elemi-tevekenyseg} fogalomra, de ebben a jegyzetben ezt kerüljük. Ellenkező esetben összekeverhető lenne  egy hasonló nevű másik fogalommal: az \fogalom{atomi-muvelet} (\fogalomangolul{atomi-muvelet}) kifejezetten a pillanatszerűnek tekinthető, időbeli kiterjedés nélkül modellezett tevékenységekre utal. Az atomokhoz hasonlóan az atomi művelet nem osztható: vagy el se kezdődött, vagy már befejeződött, de nem találhatjuk magunkat olyan időpillanatban, amikor részben már lezajlott, de még folyamatban van. Ezzel szemben az elemi tevékenység időbeli kiterjedéssel bír, és a modell megenged olyan időpontot, amikor épp folyamatban van; még ha nem is részletezi, a tevékenység mely elemei milyen készültségi fokon vannak. A tevékenységek kezdetét és befejezését viszont már atominak, pillanatszerűnek tekintjük.
\end{megjegyzes}

\subsection{Szekvencia}
Ha a modelljeink csak egymástól izolált elemi tevékenységeket tartalmaznának, nem sok hasznos tudást fejeznének ki. A folyamatmodellek igazi erőssége, hogy a tevékenységekből \fogalomragozva{folyamat}{folyamatot} építenek fel, amely azt fejezi ki, hogy az egyes tevékenységek egymáshoz viszonyítva mikor hajthatóak végre. A legegyszerűbb ilyen konstrukció a \fogalom{szekvencia}, ahol a tevékenységeket úgynevezett \fogalomragozva{vezerlesi-el}{vezérlési élek (vezérlésifolyam-élek)} kötik össze.

\begin{pelda}
Az ipari gyakorlatban egy C program forráskódja tipikusan nem csak egyetlen fájlból áll. Miután egy C forrásfájlt tárgykóddá fordítunk, utána össze kell \emph{linkelni} más tárgykódokkal (korábban lefordított forrásállományok, függvénykönyvtárak), hogy végül megkapjuk a futtatható állományt. Így tehát a következő folyamatot kell elvégezni: először a fordítás elemi tevékenységet kell végrehajtani, majd annak befejezte után kezdhető meg a linkelés. \Aref{fig:szintaxis/szekvencia}. ábrán ennek a \fogalomragozva{szekvencia}{szekvenciának} a jelölését látjuk; a szaggatott nyíl rákövetkezést jelöl, tehát hogy a \emph{Compile} tevékenység vége után kezdhető meg a \emph{Link}.
\end{pelda}
\remofigscalefixed{szintaxis/szekvencia}{Szekvencia grafikus szintaxisa}{\folyamatmodellscale}

\begin{megjegyzes}
Ahogy az ábrán is látható, a vezérlési éleket jelen jegyzetben egységesen szaggatott nyíllal jelöljük, de más forrásokban, különböző modellezési nyelvek szabványaiban gyakran jelölik folytonos nyíllal. 
\end{megjegyzes}


A következőkben több külön módszerrel értelmezzük a \fogalom{szekvencia} szemantikáját. Bár ez a vizsgálat feleslegesen alaposnak és szájbarágósnak tűnhet (``ágyúval verébre''), de a később előkerülő összetettebb folyamatmodell-konstrukciók megértését nagymértékben segíti.

\begin{pelda}
Hogyan szimulálhatjuk a szekvenciánk működését? Ha \aref{fig:szintaxis/szekvencia}. ábrán látható folyamatdiagramot kinyomtatjuk, és a papírra helyezünk egy régi egyforintost (vagy csavaranyát, vagy bármely egyéb jelölőt, amelyet a továbbiakban a \fogalom{token} névvel illetjük), akkor az ábra alapján könnyen követhetjük a folyamat működését. \begin{itemize}
  \item Helyezzük kezdetben a tokent az ábra bal szélén belépő szaggatott nyílra! Mivel a token nem tevékenységen áll, ezért ez úgy értelmezzük, hogy nem fut jelenleg egyik feltüntetett elemi tevékenység se.
  \item Csúsztassuk ujjunkkal kissé arrébb a tokent. Kövessük nyilat, tehát kerüljön a token a \emph{Compile} tevékenységre! Amíg a tevékenység rajzjelén áll a token, úgy tekintjük, hogy a tevékenység folyamatban van.
  \item Amikor a nyilak irányában ismét továbbmozgatjuk, a token a két tevékenység közötti szaggatott nyílszakaszra kerül. Ekkor az első tevékenység már nem fut, tehát befejeződött; ugyanakkor a második tevékenység még nem kezdődött el.
  \item Harmadszor is mozgatva a tokent, elkezdhetjük a \emph{Link} tevékenységet.
  \item Végül, az ábra jobb szélén látható nyílra helyezve a tokent, kifejezzük a második tevékenység befejeződését is.
\end{itemize}
Ha belegondolunk, a tokennel valójában  a következő állapotteret jártuk be: $\{$ még nem kezdődött el egyik tevékenység sem, \emph{Compile} folyamatban van, \emph{Compile} befejeződött és \emph{Link} még nem kezdődött el, \emph{Link} folyamatban van, befejeződött mindkét tevékenység $\}$. A folyamatmodell határozza meg ezt az öt állapotot, valamint hogy milyen állapotátmenetek megengedettek köztük (jelen esetben csak a felsorolás sorrendjében lehet állapotot váltani). A folyamat tehát ezt az állapotmodellt indukálja.
\end{pelda}

Ha a folyamatot (például a fenti példához hasonlóan token mozgatásával) szimuláljuk, egy konkrét lefutását kapjuk. A folyamat konkrét lefutásait a folyamatmodell \fogalomragozva{folyamat-peldany}{folyamatpéldányainak} nevezzük. Ez nyilván akkor lesz izgalmas fogalom, ha egy folyamatot nem csak egyszer hajtunk végre, hanem többször,
Ha belegondolunk, a tokennel valójában a végrehajtás pillanatnyi állapotát jelöltük ki, és a következő állapotteret jártuk be vele: $\{$ még nem kezdődött el egyik tevékenység sem, \emph{Compile} folyamatban van, \emph{Compile} befejeződött és \emph{Link} még nem kezdődött el, \emph{Link} folyamatban van, befejeződött mindkét tevékenység $\}$. A folyamatmodell határozza meg ezt az öt állapotot, valamint hogy milyen állapotátmenetek megengedettek köztük (jelen esetben csak a felsorolás sorrendjében lehet állapotot váltani). A folyamatmodell tehát ezt az állapotmodellt indukálja, a folyamat szimulációját pedig visszavezettük a fent konstruált állapotmodell szimulációra. A szimuláció eredményeképpen \aref{fig:szintaxis/szekvencia-ido}. ábrán látható idődiagramhoz hasonló eredményt kapunk.
 \remofigscalefixed{szintaxis/szekvencia-ido}{Szekvencia időbeli lefutása}{\folyamatmodellscale}



\subsection{Elágazás, őrfeltétel}
Azt is ki lehet fejezni megfelelő folyamatmodellel, ha nem minden lefutás ugyanazokat a tevékenységeket hajtja végre. Ilyen elágazások modellezésére szolgál a \fogalom{decision-node}, amely az első általunk megismert \fogalom{vezerlesi-elem} a folyamatmodellben.

\begin{pelda}
Bizonyos fájlokra a C fordítót, másokra a C++ fordítót kell meghívni. Ezt \aref{fig:szintaxis/elagazas-natur}. ábrán látható folyamatmodell fejezi ki, ahol a rombusz jelképezi a \fogalomragozva{decision-node}{döntési csomópontot (elágazást)}. Ennek a folyamatmodellnek az is érvényes lefutása, ha az egyik fordítót hívjuk meg, és az is, ha a másikat.

A folyamat szimulációja során először a bal oldalról belépő vezérlési élre helyezzük a tokent; ezek után szabadon választhatunk, hogy a döntési csomópontból kilépő élek közül melyikre rakjuk át. A folytatás már a jól ismert módon történik: a tokent először a választott elemi tevékenységre, majd a továbblépő vezérlési élre helyezzük. 
\end{pelda}
\remofigscalefixed{szintaxis/elagazas-natur}{Elágazás grafikus szintaxisa}{\folyamatmodellscale}

Természetesen 2 helyett 3, 4, stb. \fogalomragozva{ag}{ágú} döntési csomópont is elképzelhető.

Az elágazási pontnál bármelyik \fogalomragozva{ag}{ágat} is választjuk, a folyamatmodell egy érvényes lefutását kapjuk. Másképpen szólva: a modell nem fejezi ki azt az információt, hogy mi alapján dönthető el, melyik esetben melyik lehetőség fog megtörténni. A korábban tanult szóhasználattal élve \fogalomragozva{nemdeterminizmus}{nemdeterminizmust} mutat a modell. Gyakran hasznos így modellezni, pl. ha emberi döntéstől függ a választás; vagy bármilyen egyéb esetben, ha vagy nincs rálátásunk a döntést meghatározó tényezőkre, vagy a modellezés jelenlegi absztrakciós szintjén a szükséges részleteket el akarjuk hanyagolni. 

Gyakran esetekben azonban a rendszermodellünkben elérhető olyan információ, amely meghatározza, hogy a folyamat végrehajtása melyik ágon történhet, determinisztikussá téve a választást. Más modelleknél erről nincs szó, de a rendelkezésre álló információ alapján legalább időnként csökkenthető a választási lehetőségek száma. Mindkét esetben a szoros értelemben vett folyamatmodellen kívüli tudás alapján kizárjuk a döntés után előálló ágak némelyikét; erre pedig (az állapotgépekhez hasonló módon) az ún. \fogalom{orfeltetel} szolgál. 

\begin{pelda}
Elérhető az \code{ext} karakterlánc, amely a fodítandó forrásfájl kiterjesztését adja meg. Ez alapján minden esetben eldönthető, hogy melyik nyelv fordítóprogramját kell végrehajtani. \Aref{fig:szintaxis/elagazas-orfeltetel}. ábrán látható folyamatmodell őrfeltételekkel fejezi ezt ki.
\end{pelda}

\remofigscalefixed{szintaxis/elagazas-orfeltetel}{Elágazás grafikus szintaxisa őrfeltételekkel}{\folyamatmodellscale}

A korábban bevezetett fogalmaknak megfelelően akkor determinisztikus a folyamatmodell, ha minden egyes elágazás minden végrehajtásánál kizárják egymást az őrfeltételek; és akkor teljesen specifikált, ha minden egyes elágazás minden végrehajtásánál az őrfeltételek legalább egyike mindig teljesül. Ha nincsenek őrfeltételek megadva, az úgy tekintendő, mintha az állandó ``[igaz]'' őrfeltételt alkalmaztuk volna.

\subsection{Merge (besorolódás)}
Gyakran egy elágazás különböző \fogalomragozva{ag}{ágai} egy adott ponton túl egyformán folytatódnak. Ennek kifejezésére szolgál egy újabb vezérlési elem, a \fogalom{merge-node}. Sajnos nem terjedt el rá frappáns magyar név, így leggyakrabban az angol merge szót használjuk.

\begin{pelda}
Akár C, akár C++ nyelvű forrásfájt fordítottunk le, utána mindenképp a linkelés következik. \Aref{fig:szintaxis/elagazas-orfeltetel-merge}. ábrán feltüntetett merge csomópont (rajzjele egyezik a döntési csomópontéval) éppen ezt fejezi ki. A modell szimulációjakor, miután az egyik fordítási tevékenységet végrehajtottuk, a token a merge csomópontba mutató nyilak egyikén áll; ezután egyszerűen átmozgathatjuk a merge csomópont túloldalára, hogy utána már a \emph{Link} tevékenység végrehajtása következhessen. Akármelyik ágról is érkezik a token, a merge csomópont után ugyanazon kimenő vezérlési élre kerül; ez ahhoz hasonlatos, mint amikor a közúti forgalomban egy közlekedési sáv megszűnésekor két járműoszlopból is ugyanabba a sávba sorolódnak be a járművek. \Aref{fig:szintaxis/elagazas-orfeltetel-merge-ido}. ábra idődiagramon mutat be két eltérő lefutást.  
\end{pelda}

\remofigscalefixed{szintaxis/elagazas-orfeltetel-merge}{Elágazás és merge (besorolódás) grafikus szintaxisa}{\folyamatmodellscale}

\remofigscalefixed{szintaxis/elagazas-orfeltetel-merge-ido}{Elágazás és merge (besorolódás) kétféle lefutása idődiagramon}{\folyamatmodellscale}


Természetesen a többágú döntési csomópont mintájára többágú merge is elképzelhető. További különleges eset, ha a döntési és merge csomópontok között valamelyik ágon csak egy üres vezérlési él vezet, semmilyen tevékenység nem hajtódik végre; ilyet akkor használunk, ha egy tevékenység végrehajtása opcionális, vagy egy döntés valamilyen kimenetele esetén nincs teendő.

\begin{pelda}
Valójában csak olyankor kell lefordítani egy forrásállományt, ha a fordítóprogram utolsó végrehajtása óta módosult; egyéb esetben a régi tárgykódot meghagyva a fordítási lépés kihagyható. Ilyen elven épített folyamatot mutat be \aref{fig:szintaxis/elagazas-ures}. ábra.  
\end{pelda}

\remofigscalefixed{szintaxis/elagazas-ures}{Elágazás üres ággal}{\folyamatmodellscale}


\subsection{Ciklus}
Ha már megismertük a döntés és merge vezérlési elemeket, akkor építhetünk velük \fogalom{ciklus}t, amely a folyamat egy részletét többször is képes ismételni. 

\begin{pelda}
\Aref{fig:szintaxis/ciklus}. ábra olyan folyamatot mutat be, ahol a fordítás után megvizsgáljuk, találtunk-e fordítási hibát; amennyiben van hiba, akkor azt megpróbáljuk kijavítani, és újrafordítjuk az állományt. Előfordul, hogy továbbra is vannak hibák, ekkor ismét a kód szerkesztése és újrafordítás következik. Ezek a tevékenységek mindaddig ismétlődnek, amíg végül el nem tűnnek a hibák.
\end{pelda}

\remofigscalefixed{szintaxis/ciklus}{Ciklus grafikus szintaxisa}{\folyamatmodellscale}

\begin{definicio}
	A \fogalom{ciklus} olyan folyamatmodell (részlet), amelyben egy elágazás valamelyik ágán az elágazást \emph{megelőző} merge csomópontba jutunk vissza.
\end{definicio} 
Nem nehéz végiggondolni, hogy ciklikus folyamatok futásakor ezek a vezérlési csomópontok többször is érinthetőek. Próbáljuk ezt a fenti példán a tokenes kézi szimuláció módszerével kipróbálni!

\subsection{Konkurrens viselkedés}
Előfordulhat olyan folyamat, amelyben nincs előírva két tevékenység (vagy részfolyamat) egymáshoz képesti sorrendje, csak hogy mindkettőnek meg kell történnie. A szóban forgó két tevékenység közül történhet az egyik a másik előtt, vagy fordítva; sőt, futhatnak (részben) egyszerre is. Ilyen viselkedést fejez ki a \fogalom{fork-node} és a \fogalom{join-node} párosa (itt ismét nincsenek általánosan elfogadott magyar fordítások).

\begin{definicio}
Két bekövetkező tevékenység vagy esemény \fogalom{konkurrens}, ha a bekövetkezési sorrendjükre nézve nincs megkötés.
\end{definicio} 

\begin{pelda}
\Aref{fig:szintaxis/fork-join}. ábra olyan folyamatot mutat be, ahol két forrásfájlt is lefordítunk, azonban a sorrendjük nincs meghatározva. Fordítható az 1-es számú állomány a 2-es előtt, vagy fordított sorrendben. Ha többmagos processzorunk van, érdemes lehet a két fájl fordításával egyszerre is megpróbálkozni.

Ezt a folyamatmodellt a következőképpen szimulálhatjuk: először természetesen a bal szélről belépő vezérlési élen van a token. A következő lépésben a fork csomópont hatására \emph{megkettőzzük} a tokent: az egyik token a felső, a másik az alsó kimenő vezérlési élre kerül. A továbbiakban szabadon választhatóan akármelyik token léptethető. Például elkezdheti először a felső token a tevékenységet, majd befejezheti, mielőtt az alsó elkezdené és befejezni a saját tevékenységét. Egy másik lehetőség, hogy a felső token elkezdi a felső tevékenységet, majd az alsó token az alsó tevékenységet, így átlapolva a két tevékenység végrehajtását; ezek után akármilyen sorrendben befejezhetik a saját tevékenységeiket. Számos lehetőség van; ám végül így vagy úgy, de eljutunk abba a helyzetbe, amikor mindkét token a join csomópont egy-egy bemenő vezérlési élén van. Ekkor egyetlen lépésként a két tokent újra \emph{összeolvasztjuk}, és egyetlen tokent helyezünk a join kimenő élére. Néhány lehetséges lefutás látható \aref{fig:szintaxis/fork-join-ido}. ábrán.
\end{pelda}
\remofigscalefixed{szintaxis/fork-join}{Fork és join grafikus szintaxisa}{\folyamatmodellscale}
\remofigscalefixed{szintaxis/fork-join-ido}{Fork és join néhány lehetséges lefutása idődiagramon}{\folyamatmodellscale}

Nagyon fontos megérteni, hogy a két \fogalom{parhuzamos-folyam} megvárja egymást (szinkronizál) a join csomópontnál; egyik se haladhat tovább, amíg a join csomópont összes bemenő vezérlési élére nem érkezik token.  

\subsection{Teljes folyamatok}
Eddig csak a folyamatok építőelemeivel foglalkoztunk; most megnézzük, hogy lehet a segítségükkel egy egész folyamatot leírni az elejétől a végéig. Ehhez csupán két új vezérlési csomópontra lesz szükségünk; ezek az új elemek a folyamat kezdetét jelentő, egyszerű körrel/koronggal jelölt \fogalom{flow-begin}, valamint a folyamat befejeztét jelentő és a dupla falú körrel jelölt \fogalom{flow-end}.

\begin{pelda}
Vegyük az \aref{fig:szintaxis/flow-begin-end-szekvencia}. ábrán látható, \emph{Build} névvel illetett egyszerű folyamatot! Jól látható, hogy a teljes folyamat két elemi tevékenység szekvenciájából áll. A folyamat szimulációját úgy kezdjük meg, hogy a kezdőcsomópontban létrehozunk és az onnan kilépő vezérlési élre mozgatunk egy tokent; ez jelképezi a \emph{Build} folyamat elindulását. Ezek után a szekvencia a már megismert módon szimulálható, amíg végül a \emph{Link} tevékenységből kilépő vezérlési élre nem kerül a token. Ekkor a folyamat befejeződhet, amelyet úgy jelzünk, ha a célcsomópontba vezető élről a célcsomópontba mozgatjuk és egyúttal felszedjük a tokent. A lefutás idődiagramját \aref{fig:szintaxis/teljes-folyamat-ido}. ábra mutatja; jól látható, hogy az egyes tevékenységek végrehajtása teljes egészében a folyamat futása alatt zajlik.
\end{pelda}

\remofigscalefixed{szintaxis/flow-begin-end-szekvencia}{Flow begin és flow end grafikus szintaxisa}{\folyamatmodellscale}
\remofigscalefixed{szintaxis/teljes-folyamat-ido}{Teljes folyamat idődiagramja}{\folyamatmodellscale}

\subsection{Hierarchikus folyamatmodellek}
Egészen idáig elemi tevékenységeket használtunk a folyamatainkban. Azonban lehetőségünk van összetett tevékenységek modellezésére is, ahol a tevékenység belső lépéseit egy külön folyamatmodell írja le. Egyfelől a hierarchikus modellezés elvét követve egy alfolyamat beágyazható tevékenységként egy főfolyamatba; másrészt elkülönítetten definiált folyamatokra is hivatkozhat egy tevékenység.  

\begin{pelda}
\Aref{szintaxis/hierarchia-teljes}. ábra az alfolyamattá részletezett tevékenység használatát mutatja be, míg \aref{fig:szintaxis/hivas-natur}. ábra az előzővel azonos jelentésű folyamatot épít fel úgy, hogy a folyamat első tevékenysége hivatkozza (hívja) \aref{fig:szintaxis/flow-begin-end-szekvencia}. ábrán látható, korábban definiált folyamatot.
\end{pelda}

\remofigscalefixed{szintaxis/hierarchia-teljes}{Hierarchia grafikus szintaxisa}{\folyamatmodellscale}

% \remofigscalefixed{szintaxis/hierarchia-ido}{Hierarchia időbeli lefutása}{\folyamatmodellscale}

\remofigscalefixed{szintaxis/hivas-natur}{Hívás grafikus szintaxisa}{\folyamatmodellscale}

% \remofigscalefixed{szintaxis/hivas-ido}{Hívás időbeli lefutása}{\folyamatmodellscale}
% 
% Beágyazható a “főfolyamatba”, ha helyes a finomítás, azaz
% 
% • A lépések együtt ugyanazt állítják elő, mint a folyamat
% 
% • Nincs olyan eset, amit nem kezelünk a hívó fél szintjén
% 
% • (Input/output konzisztencia)


\subsection{Folyamatpéldányok}

\begin{pelda}
Vegyük példának \aref{fig:szintaxis/flow-begin-end-szekvencia}. ábrán látható folyamatmodellt, és szimuláljuk. Ahogy \aref{fig:szintaxis/teljes-folyamat-ido}. ábra idődiagramja is mutatja, a szimuláció alatt sorban a következő események következtek be: \begin{enumerate}
  \item A \emph{Build} folyamat elkezdődik.
  \item A \emph{Compile} tevékenység elkezdődik.
  \item A \emph{Compile} tevékenység befejeződik.
  \item A \emph{Link} tevékenység elkezdődik.
  \item A \emph{Link} tevékenység befejeződik.
  \item A \emph{Build} folyamat befejeződik.
\end{enumerate}
\end{pelda}

% \remofigscalefixed{szintaxis/szekvencia-hivott}{Szekvenciális folyamat grafikus szintaxisa}{\folyamatmodellscale}
%  \remofigscalefixed{szintaxis/szekvencia-hivott-ido}{Szekvenciális folyamat időbeli lefutása}{\folyamatmodellscale}

Ha egy folyamatmodellt szimulálunk (például a korábban bemutatott manuális módszerrel, token mozgatásával), akkor a folyamat egy konkrét lefutását kapjuk. A folyamat konkrét lefutásait a folyamatmodell \fogalomragozva{folyamat-peldany}{folyamatpéldányainak} nevezzük. A folyamatpéldány olyan események sorozata, amelyek a folyamatot alkotó elemi tevékenységek kezdetét és befejezését jelzik, illetve az egész folyamat kezdetét és befejezését. A folyamatmodell szemantikája voltaképp az, hogy ezen eseményeket azonosítja, és lehetséges sorrendjükre tesz megkötéseket.

\begin{definicio}
	Egy folyamatmodellhez tartozó \fogalom{folyamat-peldany} olyan diszkrét eseménysor, amelyet a következő jellegű események alkotják, a folyamatmodell által megszabott időrendben: 	\begin{itemize}
	  \item a folyamat kezdete,
	  \item a folyamatot alkotó egyik tevékenység kezdete, 
	  \item a folyamatot alkotó egyik tevékenység vége, 
	  \item a folyamat vége.
	\end{itemize}
\end{definicio}
\begin{megjegyzes}
Egy folyamatnak több folyamatpéldánya lehet; sőt, több olyan példánya is, amely ugyanolan eseményeket tartalmaz ugyanolyan sorrendben.
\end{megjegyzes}


A folyamatmodellek és folyamatpéldányok közti viszony nyilván akkor lesz izgalmas, ha egy folyamatot nem csak egyszer hajtunk végre, hanem többször, egymás után vagy akár részben átlapolódva. Az egyszerre végrehajtott folyamatpéldányokat úgy lehet szimulálni, hogy minden folyamatpéldányhoz egy-egy tokent rendelünk, amelyik a példány pillanatnyi állapotát jellemzi; ezután az összes tokent felrakjuk a folyamat diagramjára, és külön-külön léptetgetjük őket. 

\begin{megjegyzes}
A több folyamatpéldány reprezentálására szolgáló tokensokaság nem keverendő össze azzal az esettel, amikor egy \fogalom{fork-node} hatására töbszörözzük egyetlen folyamatpéldány tokenjét.  A megkülönböztetést az indokolja, hogy a join csomópontnál természetesen továbbra is csak egyazon folyamatpéldányhoz tartozó szétvált tokenek egyesülnek. Így biztosítható, hogy minden egyes folyamatpéldány önmagában értelmes, a folyamatmodellel konform eseménysor. Szimuláció közben célszerű úgy felfogni, hogy minden folyamatpéldánynak különböző színű tokenje van, és a fork ill. join csomópontok csak egyszínű tokeneket vágnak szét ill. egyesítenek. 
\end{megjegyzes}

\iflabeldef{cha:teljesitmenymodellezes}{\Aref{cha:teljesitmenymodellezes}.}{A \emph{Teljesítménymodellezés}} fejezetben kifejezetten azzal az esettel foglalkozunk majd, amikor ugyanaz a folyamat egyszerre nagyon sok példányban fut. Ilyen esetben a szimuláció során nem is érdemes a tokenekkel egyenként vesződni; csak azt tartjuk számon, hogy hány token tartózkodik éppen a diagram egy adott pontján.




\section{Programok vezérlési folyama}

\subsection{Alapismeretek}


\fogalom{vezerlesi-folyam}

\fogalom{komplexitas}

\fogalom{ciklomatikus-komplexitas}

\fogalom{rekurzio}



%\section{Vezérlési folyamok folyamatmodelljei}



\subsubsection{Leképzés}

\begin{minipage}{\balhasab}
\begin{lstlisting}
<statement1>
<statement2>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-01}{\folyamatmodellscale}
\end{minipage}



\begin{minipage}{\balhasab}
\begin{lstlisting}
if (<expression>)
	<statement>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-02}{\folyamatmodellscale}
\end{minipage}



\begin{minipage}{\balhasab}
\begin{lstlisting}
if (<expression>)
	<statement1>
else
	<statement2>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-03}{\folyamatmodellscale}
\end{minipage}

\subsubsection{Összetett példa ábrázolása}

\begin{minipage}{\balhasab}
\begin{lstlisting}
while (<expression>)
	<statement>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-04}{\folyamatmodellscale}
\end{minipage}



\begin{minipage}{\balhasab}
\begin{lstlisting}
do
	<statement>
while (<expression>)
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-05}{\folyamatmodellscale}
\end{minipage}



Nézzünk meg egy összetettebb példát!

\begin{minipage}{\balhasab}
\begin{lstlisting}
while (a != b) {
	if (a > b) {
		a = a - b;
	} else {
		b = b - a;
	}
}
return a;
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-06}{\folyamatmodellscale}
\end{minipage}

%\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-07}{\folyamatmodellscale}

Lépésenként átalakítva:

\begin{minipage}{0.2\linewidth}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-07}{\folyamatmodellscale}
\end{minipage}
\begin{minipage}{0.35\linewidth}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-08}{\folyamatmodellscale}
\end{minipage}
\begin{minipage}{0.45\linewidth}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-09}{\folyamatmodellscale}
\end{minipage}

\subsection{Komplexitás}

\begin{definicio}
\fogalom{ciklomatikus-komplexitas}: $M$ = $E$ - $N$ + 2, ahol ...
\end{definicio}

\remofigscale{vezerlesi-folyamat/ciklomatikus-komplexitas}{A ciklomatikus komplexitás fogalmai. $E$: élek (narancssárga), $N$ csomópontok (kék)}{\folyamatmodellscale}

\begin{megjegyzes}
	A ciklomatikus komplexitással a \szofttech tárgy is foglalkozik.
\end{megjegyzes}

\subsection{Példa: $n!$ meghatározása}

Vizsgáljuk meg az alábbi programkódot, ami egy szám faktoriálisát határozza meg!

\begin{lstlisting}
int fact(int n) {
	return (n == 0) ? 1 : n * fact(n - 1);
}
\end{lstlisting}

A \lstinline{?:} operátor tömör kódot eredményez, de esetünkben fontosabb szempont, hogy a kódban bejárható útvonalakat lássuk. Mentsük el továbbá a visszatérési értéket egy átmeneti változóba. Így az alábbi kódot kapjuk:

\begin{minipage}{\balhasab}
\begin{lstlisting}
int fact(int n) {
	int tmp1;
	if (n == 0) {
		tmp1 = 1;
	} else {
		int tmp2 = fact(n - 1);
		tmp1 = n * tmp2;
	}
	return tmp1;
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{faktorialis}{\folyamatmodellscale}
\end{minipage}

\subsection{Példa: $n \choose k$ meghatározása}

Az alábbi rekurzív függvény meghatározza $n \choose k$ értékét. A számításhoz felhasználjuk, hogy ${0 \choose 0} = 1$ és ${n \choose k} = {n-1 \choose k} + {n-1 \choose k-1}$.


\begin{minipage}{\balhasab}
\begin{lstlisting}
int choose(int n, int k) {
	if (k < 0 || k > n) {
		return 0;
	} else if (k == 0 && n == 0) {
		return 1;
	} else {
		int x = spawn choose(n - 1, k);
		int y = spawn choose(n - 1, k - 1);
		sync;
		return x + y;
	}
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{n-alatt-a-k}{\folyamatmodellscale}
\end{minipage}



\section{Folyamatmodellek használata}

\subsection{Modellezés több aspektus szerint}\label{sec:folyamatmodell-tobb-aspektusbol}
TODO Autógyáras-futószalagos példa.\label{exmpl:autogyaros-pelda}

\subsection{Jólstrukturált folyamatok}\label{sec:jolstrukturalt-folyamatok}

Eddig semmilyen megszorítást nem tettünk arra, hogy a vezérlési élek mely csomópontokat melyekkel köthetik össze; így pedig sok értelmetlen vagy helytelenül működő folyamatmodell építhető. Ráadásul az egyébként értelmes folyamatmodellek is gyakran átláthatatlanok, nehezen érthetőek lehetnek. Az átláthatóság egyik fő akadálya, ha egy bonyolult részfolyamatba több ponton is be lehet lépni, és több ponton is ki lehet lépni belőle.

Ezért szokás a folyamatmodelleknek az alábbiakban definiált "biztonságos" részhalmazát elkülöníteni, amely megengedett blokkokból építkezik csak.

% \begin{definicio}
% 	Egy \fogalom{reszfolyamat} akkor \fogalom{jolstrukturalt}, ha egyféleképpen kezdődik el és egyféleképpen fejeződik be; továbbá összetett (több elemből álló) részfolyamatok esetén annak alkotórészei hasonlóan jólstrukturáltak, és megengedett módon vannak összekapcsolva. Egy \fogalom{folyamat} akkor jólstrukturált, ha az egész ilyen módon épül fel.
% \end{definicio}

\begin{definicio}
A következő (egy belépési és egy kilépési pontú) részfolyamatokat tekintjük \fogalom{jolstrukturalt} blokknak (más néven jólstrukturált részfolyamatnak):

\begin{itemize}
\item egyetlen elemi tevékenység önmagában;
\item egyetlen folyamathivatkozás/hívás (máshol definiált folyamatmodell újrafelhasználása);
\item üres vezérlési élszakasz;
\item ,,soros kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok szekvenciája (egyszerű vezérlési éllel egymás után kötve őket);
\item ,,\emph{Fork-Join} kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok egy $n$ ágú \emph{Fork} és egy $n$ ágú \emph{Join} közé zárva;
\item ,,\emph{Decision-Merge} kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok egy $n$ ágú \emph{Decision} és egy $n$ ágú \emph{Merge} közé zárva;
\item ,,Ciklus": egy kétágú \emph{Merge} csomóponttal kezdődik, amely után egy jólstrukturált $P_1$ blokk következik, majd egy kétágú \emph{Decision}, melynek egyik ága a részfolyamat vége, a másik a $P_2$ jólstrukturált blokkokon keresztül az előbbi \emph{Merge}-be tér vissza.
\end{itemize}
Egy teljes folyamatmodell jólstrukturált, ha egyetlen belépési pontja (\emph{Flow begin}) és kilépési pontja (\emph{Flow end}) egy jólstrukturált blokkot zár közre.
\end{definicio}

Amint az a definícióból látszik, egy teljes folyamat lehet úgy jólstrukturált, hogy pl. egy egyszerű elemi tevékenység, egy fork-join blokk és egy ciklus szekvenciájából áll, de csak ha a fork-join blokk és a ciklus maga is kisebb jólstrukturált blokkokból van felépítve.

A jólstrukturáltság célja, hogy áttekinthetőbbé tegye a folyamatot, és hogy bizonyos hibalehetőségeket (pl. holtpont) eleve kizárjon. A folyamatmodellekre jellemző hibamintákról később lesz szó; ezek egy része jólstrukturált modellnél elő sem fordulhat. Ha a folyamat nem jólstrukturált, akkor külön ellenőrzési eljárásokkal kell kizárni a hibalehetőségeket. Mindemellett nem csak a jólstrukturált folyamatmodellek lehetnek értelmesek; előadáson volt példa nem jólstrukturált, de értelmes folyamatra (ld. ,,Jólstrukturált folyamatok'' c. dia); illetve hasonló esetet láthattunk \aref{sec:folyamatmodell-tobb-aspektusbol}. szakaszban is, amikor az autógyár teljes működését egyetlen nagy folyamaton tüntettük fel.

Léteznek olyan folyamatmodellezési nyelvek is, amelyek nem engedik tetszőleges gráfként megalkotni a vezérlési folyamot, hanem kizárólag jólstrukturált blokkokat lehet létrehozni és más jólstrukturált blokkokból felépíteni. Ilyen nyelv pl. a \rovidites{BPEL} (alap jelkészlete), vagy a programozásoktatásból ismerős Nassi-Shneiderman-féle \fogalom{struktogram}. Ezeken a nyelveken a megkötések miatt bizonyos folyamatokat csak körülményesebben lehet megfogalmazni; cserébe az adott nyelven készített összes folyamatról külön ellenőrzés nélkül tudható, hogy rendelkezik a jólstrukturáltság fent tárgyalt összes előnyével.

A tanultak szerint az imperatív programnyelvek vezérlésifolyam-gráfja is folyamatmodell; mit jelent a programokra nézve a jólstrukturáltság? A program vezérlési folyamja akkor lesz jólstrukturált, ha egy belépési és egy kilépési pontja van, és egyszerű utasításokból szekvenciális egymás után fűzéssel áll össze, ill. elágazásokat vagy ciklusokat tartalmaz (ill. megfelelő programozási nyelv/platform esetén akár párhuzamosan végrehajtott blokkokat). A \lstinline{goto}, \lstinline{break}, idő előtti \lstinline{return} és hasonló jellegű ugrások azonban túlmutatnak a jólstrukturáltságon, más szóval kivezetnek a jólstrukturált modellek közül.  Ennek megfelelően könnyen átláthatatlanná tehetik a forráskódot, így mértékletes alkalmazásukat szokták javasolni, lehetőség szerint kerülendőek. Megjegyzendő, hogy ritkán, de olyan eset is van, ahol épp pl. a \lstinline{return} használata tesz egy mély vezérlési strukturát egyszerűbbé. 

% \section{Adatfolyamhálók}
% 
% \fogalom{adatfolyam} \rovidites{DFN}
% 
% \fogalom{tevekenyseg}

% 
% 
% 
% \fogalom{folyamatmotor} (\fogalomangolul{folyamatmotor})
% 
% \newcommand{\prioritas}{\pi}
% \newcommand{\tuple}[1]{\langle #1 \rangle}
% 
% tüzelések: $\tuple{s_0; \mathrm{in} = c_0; s_1; \mathrm{out} = c_2; \prioritas}$
% 
% adatfolyam csomópont: $n = (I_n, O_n, S_n, s_n^0, R_n, M_n)$


\section{Szabványos formalizmusok\kieg}

Az \rovidites{OMG} (\roviditesangolulkifejtve{OMG}) két szabványa:

\rovidites{UML}~\cite{UML} \fogalom{aktivitas-diagram} (\fogalomangolul{aktivitas-diagram})

\rovidites{BPMN}~\cite{omg2011bpmn}

%\fogalom{folyamatmodell} \fogalom{vegrehajthato-modell}



\section{Kitekintés}

\subsection{Döntési diagramok}

\fogalom{folyamatabra} (\fogalomangolul{folyamatabra})

\fogalom{dontesi-diagram} (\fogalomangolul{dontesi-diagram})

\fogalom{folyamatabra} (\fogalomangolul{folyamatabra})

\subsection{PERT\kieg}


\rovidites{PERT} (nem tud elágazást ábrázolni)

\subsection{Szabványok\kieg}

\rovidites{BPEL}

\subsection{Technológiák\kieg}

\subsubsection{Adatelemzés}

Az Airbnb cég Airflow eszköze\footnote{\url{https://github.com/airbnb/airflow}} adatelemzési folyamatok definiálására és végrehajtására alkalmas.

Több olyan rendszer is létezik, amelyek tudományos folyamatok futtatását teszik lehetővé (\emph{scientific workflow engine}), beleértve az adatok összegyűjtését, elemzését és vizualizálását. Ilyen rendszerek például a
Kepler\footnote{\url{https://kepler-project.org/}} és a Taverna\footnote{\url{http://taverna.incubator.apache.org/}}.

\subsubsection{Üzleti folyamatmodellek}

Az üzleti folyamatok modellezésére használt szoftverek manapság tipikusan a BPMN 2.0 szabványt valósítják meg.\footnote{\url{https://en.wikipedia.org/wiki/List_of_BPMN_2.0_engines}}

Ilyen eszközök pédául a jBPM\footnote{\url{http://www.jbpm.org/}}, a Bonita BPM\footnote{\url{http://www.bonitasoft.com/}}, Camunda\footnote{\url{https://camunda.org/}} és az Eclipse Stardust\footnote{\url{https://www.eclipse.org/stardust/}}.
