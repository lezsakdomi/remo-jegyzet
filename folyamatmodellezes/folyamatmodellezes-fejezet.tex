% !TeX spellcheck = hu_HU
\topic{Folyamatmodellezés}

\graphicspath{ {./folyamatmodellezes/figures/} }

\lstset{
	language=c,
	morekeywords={sync}
}

% diasorok:
% - https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/bsc-t%C3%A1rgyak/rendszermodellez%C3%A9s/15/04-folyamatmodellezes.pdf
% - https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/bsc-t%C3%A1rgyak/rendszermodellez%C3%A9s/15/05-bpmn-dfn.pdf

Autómegosztó szolgáltatásban egy fuvar rendeléséhez, banki ügyintézés esetén a hitelbírálathoz, egyetemi környezetben egy tárgy felvételéhez egy jól meghatározott \fogalom{folyamat} tartozik. Amennyiben ezeket digitálisan szeretnénk végezni, fontos, hogy a folyamatokat precízen definiáljuk.

A folyamatmodelleket széleskörűen használják, többek között az informatikában rendszerek működtetésére, protokollok specifikációjára, adatelemzési folyamatok specifikálására.

\section{Folyamatok}

A \fogalomragozva{viselkedes-alapu-modellezes}{viselkedési modellek} a rendszer viselkedését többféle aspektusból jellemezhetik:

\begin{itemize}
	\item Az \fogalomragozva{allapot-alapu-modellezes}{állapot alapú modellek} esetén a rendszereket az \fogalomragozva{allapot}{állapotukkal} jellemezzük, ami meghatározza, hogy a rendszerünk egy adott időpillanatban ,,milyen'' és ,,hogyan változhat''? Ezekkel a modellekkel bővebben  \iflabeldef{sec:allapot-alapu-modellezes}{\Aref{sec:allapot-alapu-modellezes}.}{\emph{Állapot alapú modellezés}} fejezetben foglalkoztunk.
	\item A \fogalomragozva{folyamatmodell}{folyamatmodellek} fókusza az, hogy ,,mit csinál'' egy rendszer, milyen módon jellemezhető a rendszerben az adatok és a vezérlés áramlása.
\end{itemize}

\begin{megjegyzes}
A folyamatmodellezés történeti előzményei:

\begin{itemize}
	\item Programok vezérlési szerkezete
	\item Ütemezés (pl. GANTT diagramok): tevékenységek állapota, időzítése, és függőségei
	\item Gyártási/irodai folyamatok modellezése
	\item IDEF-0: 1980-as évek, US AirForce: logikai függőségek (adatfüggőség és végrehajtási logika nem)
	\item Logisztikai folyamatok leírása
	\item Üzemeltetés: ,,runbook''
\end{itemize}

TODO: IDEF-0 ábra

TODO: GANTT ábra \footnote{\url{wiki}}
\end{megjegyzes}

A folyamatmodellezés esetén a rendszerünk viselkedését egy folyamattal jellemezzük.

\begin{definicio}
	A \fogalom{folyamat} lépések sorozata, melyek sorrendben történő végrehajtása valamilyen célra vezet.
\end{definicio}	

\section{A folyamatmodellek építőkövei}

Az alábbiakban bemutatjuk a folyamatmodellek építőköveinek nevét, grafikus jelölését és szemantikáját.

\begin{definicio}
	\fogalom{elemi-tevekenyseg}
\end{definicio}

\begin{definicio}
	\fogalom{szekvencia}
\end{definicio}

\begin{definicio}
	\fogalom{orfeltetel}
\end{definicio}

\begin{definicio}
	\fogalom{elagazas}
\end{definicio}

\begin{definicio}
	\fogalom{ciklus}
\end{definicio}

\begin{definicio}
	\fogalom{hierarchia}
\end{definicio}

\begin{definicio}
	\fogalom{hivas}
\end{definicio}



\fogalom{folyamatabra} (\fogalomangolul{folyamatabra})

\fogalom{dontesi-diagram} (\fogalomangolul{dontesi-diagram})



\fogalom{folyamatabra} (\fogalomangolul{folyamatabra})

\fogalom{vezerlesi-folyam}

\fogalom{komplexitas}

\fogalom{ciklomatikus-komplexitas}

\fogalom{rekurzio}



\section{Vezérlési folyamok folyamatmodelljei}

\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
<statement1>
<statement2>
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}



\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
if (<expression>)
	<statement>
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}



\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
if (<expression>)
	<statement1>
else
	<statement2>
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}



\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
while (<expression>)
	<statement>
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}



\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
do
	<statement>
while (<expression>)
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}

Nézzünk meg egy összetettebb példát!

\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
while (a != b) {
	if (a > b) {
		a = a - b;
	} else {
		b = b - a;
	}
}
return a;
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}

Vizsgáljuk meg az alábbi programkódot, ami egy szám faktoriálisát határozza meg!

\begin{lstlisting}
int fact(int n) {
	return (n == 0) ? 1 : n * fact(n - 1);
}
\end{lstlisting}

A \lstinline{?:} operátor\footnote{Elvis operátor.} tömör kódot eredményez, de esetünkben fontosabb szempont, hogy a kódban bejárható útvonalakat lássuk.

\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
int fact(int n) {
	int tmp1;
	if (n == 0) {
		tmp1 = 1;
	} else {
		int tmp2 = fact(n - 1);
		tmp1 = n * tmp2;
	}
	return tmp1;
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}

Az alábbi rekurzív függvény meghatározza $n \choose k$ értékét. A számításhoz felhasználjuk, hogy ${0 \choose 0} = 1$ és ${n \choose k} = {n-1 \choose k} + {n-1 \choose k-1}$.


\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
int choose(int n, int k) {
	if (k < 0 || k > n) {
		return 0;
	} else if (k == 0 && n == 0) {
		return 1;
	} else {
		int x = spawn choose(n - 1, k);
		int y = spawn choose(n - 1, k - 1);
		sync;
		return x + y;
	}
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	x
\end{minipage}



\section{Formalizmusok}

\rovidites{UML} \fogalom{aktivitas-diagram} (\fogalomangolul{aktivitas-diagram})

\rovidites{BPMN}

%\fogalom{folyamatmodell} \fogalom{vegrehajthato-modell}




\szgarch tárgy

\section{Jólstrukturált folyamatok}\label{sec:jolstrukturalt-folyamatok}

A folyamatmodellek a tanultak szerint leírhatóak egy vezérlésifolyam-gráffal. Eddig azonban semmilyen megszorítást nem tettünk arra, hogy a vezérlési élek mely csomópontokat melyekkel köthetik össze; így pedig sok értelmetlen vagy helytelenül működő folyamatmodell építhető. Ráadásul az egyébként értelmes folyamatmodellek is gyakran átláthatatlanok, nehezen érthetőek lehetnek. 

Ezért szokás a folyamatmodelleknek az alábbiakban definiált "biztonságos" részhalmazát elkülöníteni, amely megengedett blokkokból építkezik csak. 

\begin{definicio}
	Egy \fogalom{reszfolyamat} akkor \fogalom{jolstrukturalt}, ha egyféleképpen kezdődik el és egyféleképpen fejeződik be; továbbá összetett (több elemből álló) részfolyamatok esetén annak alkotórészei hasonlóan jólstrukturáltak, és megengedett módon vannak összekapcsolva. Egy \fogalom{folyamat} akkor jólstrukturált, ha az egész ilyen módon épül fel.
\end{definicio}

\subsection{Jólstrukturált blokk}

A következő (egy belépési és egy kilépési pontú) részfolyamatokat tekintjük \fogalom{jolstrukturalt} blokknak (más néven jólstrukturált részfolyamatnak):

\begin{itemize}
\item egyetlen elemi tevékenység önmagában;
\item egyetlen folyamathivatkozás/hívás (máshol definiált folyamatmodell újrafelhasználása);
\item üres vezérlési élszakasz;
\item ,,soros kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok szekvenciája (egyszerű vezérlési éllel egymás után kötve őket);
\item ,,\emph{Fork-Join} kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok egy $n$ ágú \emph{Fork} és egy $n$ ágú \emph{Join} közé zárva; 
\item ,,\emph{Decision-Merge} kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok egy $n$ ágú \emph{Decision} és egy $n$ ágú \emph{Merge} közé zárva;
\item ,,Ciklus": egy kétágú \emph{Merge} csomóponttal kezdődik, amely után a jólstrukturált $P_1$ blokkok következik, majd egy kétágú \emph{Decision}, melynek egyik ága a részfolyamat vége, a másik a $P_2$ jólstrukturált blokkokon keresztül az előbbi \emph{Merge}-be tér vissza.
\end{itemize}

\subsection{Jólstrukturált folyamatmodell}

Egy teljes folyamatmodell jólstrukturált, ha egyetlen belépési pontja (\emph{Flow begin}) és kilépési pontja (\emph{Flow end}) egy jólstrukturált blokkot zár közre.

Amint az a definícióból látszik, egy teljes folyamat lehet úgy jólstrukturált, hogy pl. egy egyszerű elemi tevékenység, egy fork-join blokk és egy ciklus szekvenciájából áll, de csak ha a fork-join blokk és a ciklus maga is kisebb jólstrukturált blokkokból van felépítve.

A jólstrukturáltság célja, hogy áttekinthetőbbé tegye a folyamatot, és hogy bizonyos hibalehetőségeket (pl. holtpont) eleve kizárjon. A folyamatmodellekre jellemző hibamintákról később lesz szó; ezek egy jó része jólstrukturált modellnél elő sem fordulhat. Ha a folyamat nem jólstrukturált, akkor külön ellenőrzési eljárásokkal kell kizárni a hibalehetőségeket. Mindemellett nem csak a jólstrukturált folyamatmodellek lehetnek értelmesek; előadáson volt példa nem jólstrukturált, de értelmes folyamatra (ld. ,,Jólstrukturált folyamatok'' c. dia, vagy a gyártósoros példához tartozó ,,Együttes nézet'' c. dia).

Léteznek olyan folyamatmodellezési nyelvek is, amelyek nem engedik tetszőleges gráfként megalkotni a vezérlési folyamot, hanem kizárólag jólstrukturált blokkokat lehet létrehozni és más jólstrukturált blokkokból felépíteni. Ilyen nyelv pl. a \rovidites{BPMN} (alap jelkészlete), vagy a programozásoktatásból ismeről Nassi-Shneiderman-féle \fogalom{struktogram}. Ezeken a nyelveken a megkötések miatt bizonyos folyamatokat csak körülményesebben lehet megfogalmazni; cserébe az adott nyelven készített összes folyamatról külön ellenőrzés nélkül tudható, hogy rendelkezik a jólstrukturáltság fent tárgyalt összes előnyével.

A tanultak szerint az imperatív programnyelvek vezérlésifolyam-gráfja is folyamatmodell; mit jelent a programokra nézve a jólstrukturáltság? A program vezérlési folyamja akkor lesz jólstrukturált, ha egy belépési és egy kilépési pontja van, és egyszerű utasításokból szekvenciális egymás után fűzéssel áll össze, ill. elágazásokat vagy ciklusokat tartalmaz (ill. megfelelő programozási nyelv/platform esetén akár párhuzamosan végrehajtott blokkokat). A \lstinline{goto}, idő előtti \lstinline{return} és hasonló jellegű ugrások azonban túlmutatnak a jólstrukturáltságon; ennek megfelelően könnyen átláthatatlanná tehetik a forráskódot, így mértékletes alkalmazásukat szokták javasolni, lehetőség szerint kerülendők.


\fogalom{adatfolyam}

\fogalom{tevekenyseg}


\section{Kitekintés\kieg}


\rovidites{PERT} (nem tud elágazást ábrázolni)

\subsection{Adatelemzés}

AirBnB cég AirFlow rendszere\footnote{\url{github}}

Tudományos célú folyamatmodellező rendszerek (\emph{science workflow engines})

Kepler, Taverna, ...

\subsection{Üzleti folyamatmodellek}

jBPM\footnote{\url{}}, Bonita\footnote{\url{}}, C...\footnote{\url{http://bpmn.io}}, Eclipse Stardust\footnote{\url{}}

