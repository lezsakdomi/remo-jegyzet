% !TeX spellcheck = hu_HU
\topic{Folyamatmodellezés}

\graphicspath{ {./folyamatmodellezes/figures/} }

\lstset{
	language=c,
	morekeywords={sync}
}

\newcommand{\folyamatmodellscale}{0.42}
\newcommand{\balhasab}{0.4\linewidth}
\newcommand{\jobbhasab}{0.6\linewidth}

% diasorok:
% - https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/bsc-t%C3%A1rgyak/rendszermodellez%C3%A9s/15/04-folyamatmodellezes.pdf
% - https://inf.mit.bme.hu/sites/default/files/materials/category/kateg%C3%B3ria/oktat%C3%A1s/bsc-t%C3%A1rgyak/rendszermodellez%C3%A9s/15/05-bpmn-dfn.pdf

Az informatikában és azon kívül is számos esetben találkozunk olyan viselkedéssel, amikor megadott tevékenységek megadott sorrendben zajlanak. Például egy autómegosztó szolgáltatásban egy fuvar rendeléséhez, banki ügyintézés esetén a hitelbírálathoz, egyetemi környezetben egy tárgy felvételéhez egy jól meghatározott \fogalom{folyamat} tartozik. Amennyiben ezeket digitálisan szeretnénk végezni, fontos, hogy a folyamatokat precízen definiáljuk.

A folyamatmodelleket széleskörűen használják, többek között az informatikában rendszerek működtetésére, protokollok specifikációjára, adatelemzési folyamatok specifikálására. Látni fogjuk, hogy a szoftverek programkódjának elemzése is folyamatmodellre vezet.

\section{Folyamatok}

A \fogalomragozva{viselkedes-alapu-modellezes}{viselkedési modellek} a rendszer viselkedését többféle aspektusból jellemezhetik:

\begin{itemize}
	\item Az \fogalomragozva{allapot-alapu-modellezes}{állapot alapú modellek} esetén a rendszereket az \fogalomragozva{allapot}{állapotukkal} jellemezzük. Az állapotgép alapú viselkedésmodell arra válaszol, hogy ,,miként változhat'' a rendszer. Másként fogalmazva: a modell elsődlegesen arra összpontosít, hogy milyen állapotokban lelhető fel a rendszer (és nevekkel látja el az állapotokat), ill. milyen hatásokra mely állapotból mely állapotokba léphet át. Az másodlagosnak tekinthető, hogy ez a változás részletesebben megvizsgálva hogyan zajlik le, ezért a modell azt az egyszerűsítést alkalmazza, hogy az állapotátmenetek pillanatszerű események. Ilyen állapot alapú modellekkel bővebben  \iflabeldef{sec:allapot-alapu-modellezes}{\aref{sec:allapot-alapu-modellezes}.}{\emph{Állapot alapú modellezés}} fejezetben foglalkoztunk.
	\item Ezzel szemben a \fogalomragozva{folyamatmodell}{folyamatmodellek} fókusza az, hogy ,,mit csinál'' egy rendszer. A tevékenységeknek időbeli kiterjedést tulajdonítunk (ahelyett, hogy pillanatszerűvé egyszerűsítenénk őket), és azt vizsgáljuk, hogy mely tevékenységek végezhetőek el más tevékenységek előtt vagy után, esetleg velük átlapolódva. Ugyan a rendszer állapotainak jellemzése (adott időpontban mely tevékenységek vannak folyamatban, fejeződtek már be, stb.) implicit módon kikövetkeztethető a folyamatmodellből, de ez mintegy másodlagos; a modell a folyamatot alkotó tevékenységeknek ad nevet, és ezek viszonyának megadását várjuk el a modellezőtől.
\end{itemize}

\begin{megjegyzes}
A folyamatmodellezés történeti előzményei:

\begin{itemize}
	\item Programok vezérlési szerkezete
	\item Ütemezés (pl. GANTT diagramok): tevékenységek állapota, időzítése, és függőségei
	\item Gyártási/irodai folyamatok modellezése
	\item IDEF-0: 1980-as évek, US AirForce: logikai függőségek (adatfüggőség és végrehajtási logika nem)
	\item Logisztikai folyamatok leírása
	\item Üzemeltetés: ,,runbook''
\end{itemize}

TODO: IDEF-0 ábra

% http://ocw.mit.edu/courses/aeronautics-and-astronautics/16-885j-aircraft-systems-engineering-fall-2005/readings/sefguide_01_01.pdf
% Figure 5-7. IDEF0 Diagram Example
% http://ocw.mit.edu/terms/

\remofigscale{GanttChartAnatomy}{GANTT diagram}{0.46}

\footnote{\url{https://commons.wikimedia.org/wiki/File:GanttChartAnatomy.svg}}
\end{megjegyzes}

A folyamatmodellezés esetén a rendszerünk viselkedését egy folyamattal jellemezzük.

\begin{definicio}
	A \fogalom{folyamat} tevékenységek összessége, melyek adott rendben történő végrehajtása valamilyen célra vezet.
\end{definicio}

\section{A folyamatmodellek építőkövei}

Az alábbiakban bemutatjuk a folyamatmodellek építőköveinek nevét, grafikus jelölését és szemantikáját.


\subsection{Elemi tevékenység}

Mielőtt valódi folyamatmodelleket vizsgálnánk, először meg kell ismerkednünk azzal az esettel, amikor valamilyen viselkedés részleteit \emph{nem} modellezzük folyamatként.

\begin{pelda}
Szoftverünk C nyelvű forráskódjából futtatható programot szeretnénk előállítani; ennek egyik lépéseként egy konkrét forrásállományt le kell fordítanunk (\emph{compile}) a fordítóprogram segítségével. Mivel a fordítóprogramot nem mi készítjük, ezért nem szükséges részleteiben vizsgálnunk, hogy milyen lépésekből áll a futása. Így tehát azt mondhatjuk, hogy a fordítóprogram futása egy \fogalom{elemi-tevekenyseg}; valamikor el fog kezdődni, utána némi idővel be fog fejeződni, és nem részletezzük, hogy közben mi történik. Ebben a jegyzetben \aref{fig:szintaxis/elemi-tevekenyseg}. ábrán láthatóhoz hasonló rajzjelekkel fogjuk a hasonló elemi tevékenységeket jelölni.
\end{pelda}

\begin{definicio}
	Az \fogalom{elemi-tevekenyseg} olyan időbeli kiterjedéssel rendelkező tevékenység, amelynek a megkezdésén és befejezésén túl további részleteit nem modellezzük.
\end{definicio}

\remofigscalefixed{szintaxis/elemi-tevekenyseg}{Elemi tevékenység grafikus szintaxisa}{\folyamatmodellscale}

\begin{pelda}
Mit is értünk azalatt, hogy a fordítóprogram futtatása időbeli kiterjedéssel bír? Ahogy \aref{fig:szintaxis/elemi-tevekenyseg-ido}. ábrán látható idődiagram is illusztrálja, kezdetben a tevékenység nem fut. Valamikor a működés során eljön a tevékenység kezdete - ezt egy pillatanszerű eseményként modellezzük; utána úgy tekinthető, hogy a fordítás tevékenység \emph{folyamatban van}. Később eljön az az idő, amikor a fordítás befejeződik; ez egy újabb pillanatszerű esemény, amely után az elemi tevékenység már nincs folyamatban, befejezettnek tekinthető.
\end{pelda}

\remofigscalefixed{szintaxis/elemi-tevekenyseg-ido}{Elemi tevékenység időbeli lefutása idődiagramon}{\folyamatmodellscale}

Ahogy a fenti példa is illusztrálja, minden elemi tevékenység önmagában egy háromelemű állapotteret határoz meg: $\{$még nem kezdődött el, folyamatban van, már befejeződött$\}$; később az összetett folyamatmodellek állapotteréről is lesz szó. Látható, hogy az elemi tevékenység is leírható a korábban tanult állapotmodellezési eszköztárral; ebben az esetben viszont más a modell fókusza, más elemeket tartunk elnevezésre és vizsgálatra érdemesnek.

\begin{megjegyzes}
	Bizonyos források \fogalom{atomi} tevékenység vagy lépés néven hivatkoznak ugyanerre az \fogalom{elemi-tevekenyseg} fogalomra, de ebben a jegyzetben ezt kerüljük. Ellenkező esetben összekeverhető lenne  egy hasonló nevű másik fogalommal: az \fogalom{atomi-muvelet} (\fogalomangolul{atomi-muvelet}) kifejezetten a pillanatszerűnek tekinthető, időbeli kiterjedés nélkül modellezett tevékenységekre utal. Az atomokhoz hasonlóan az atomi művelet nem osztható: vagy el se kezdődött, vagy már befejeződött, de nem találhatjuk magunkat olyan időpillanatban, amikor részben már lezajlott, de még folyamatban van. Ezzel szemben az elemi tevékenység időbeli kiterjedéssel bír, és a modell megenged olyan időpontot, amikor épp folyamatban van; még ha nem is részletezi, a tevékenység mely elemei milyen készültségi fokon vannak. A tevékenységek kezdetét és befejezését viszont már atominak, pillanatszerűnek tekintjük.
\end{megjegyzes}

\subsection{Szekvencia}
Ha a modelljeink csak egymástól izolált elemi tevékenységeket tartalmaznának, nem sok hasznos tudást fejeznének ki. A folyamatmodellek igazi erőssége, hogy a tevékenységekből \fogalomragozva{folyamat}{folyamatot} építenek fel, amely azt fejezi ki, hogy az egyes tevékenységek egymáshoz viszonyítva mikor hajthatóak végre. A legegyszerűbb ilyen konstrukció a \fogalom{szekvencia}.

\begin{pelda}
Az ipari gyakorlatban egy C program forráskódja tipikusan nem csak egyetlen fájlból áll. Miután egy C forrásfájlt tárgykóddá fordítunk, utána össze kell \emph{linkelni} más tárgykódokkal (korábban lefordított forrásállományok, függvénykönyvtárak), hogy végül megkapjuk a futtatható állományt. Így tehát a következő folyamatot kell elvégezni: először a fordítás elemi tevékenységet kell végrehajtani, majd annak befejezte után kezdhető meg a linkelés. \Aref{fig:szintaxis/szekvencia}. ábrán ennek a \fogalomragozva{szekvencia}{szekvenciának} a jelölését látjuk; a szaggatott nyíl rákövetkezést jelöl, tehát hogy a \emph{Compile} tevékenység vége után kezdhető meg a \emph{Link}.
\end{pelda}
\remofigscalefixed{szintaxis/szekvencia}{Szekvencia grafikus szintaxisa}{\folyamatmodellscale}

A következőkben több külön módszerrel értelmezzük a \fogalom{szekvencia} szemantikáját. Bár ez a vizsgálat feleslegesen alaposnak és szájbarágósnak tűnhet (``ágyúval verébre''), de a később előkerülő összetettebb folyamatmodell-konstrukciók megértését nagymértékben segíti.

\begin{pelda}
Hogyan szimulálhatjuk a szekvenciánk működését? Ha \aref{fig:szintaxis/szekvencia}. ábrán látható folyamatdiagramot kinyomtatjuk, és a papírra helyezünk egy régi egyforintost (vagy csavaranyát, vagy bármely egyéb jelölőt, amelyet a továbbiakban a \fogalom{token} névvel illetjük), akkor az ábra alapján könnyen követhetjük a folyamat működését. \begin{itemize}
  \item Helyezzük kezdetben a tokent az ábra bal szélén belépő szaggatott nyílra! Mivel a token nem tevékenységen áll, ezért ez úgy értelmezzük, hogy nem fut jelenleg egyik feltüntetett elemi tevékenység se.
  \item Csúsztassuk ujjunkkal kissé arrébb a tokent. Kövessük nyilat, tehát kerüljön a token a \emph{Compile} tevékenységre! Amíg a tevékenység rajzjelén áll a token, úgy tekintjük, hogy a tevékenység folyamatban van.
  \item Amikor a nyilak irányában ismét továbbmozgatjuk, a token a két tevékenység közötti szaggatott nyílszakaszra kerül. Ekkor az első tevékenység már nem fut, tehát befejeződött; ugyanakkor a második tevékenység még nem kezdődött el.
  \item Harmadszor is mozgatva a tokent, elkezdhetjük a \emph{Link} tevékenységet.
  \item Végül, az ábra jobb szélén látható nyílra helyezve a tokent, kifejezzük a második tevékenység befejeződését is.
\end{itemize}
Ha belegondolunk, a tokennel valójában  a következő állapotteret jártuk be: $\{$ még nem kezdődött el egyik tevékenység sem, \emph{Compile} folyamatban van, \emph{Compile} befejeződött és \emph{Link} még nem kezdődött el, \emph{Link} folyamatban van, befejeződött mindkét tevékenység $\}$. A folyamatmodell határozza meg ezt az öt állapotot, valamint hogy milyen állapotátmenetek megengedettek köztük (jelen esetben csak a felsorolás sorrendjében lehet állapotot váltani). A folyamat tehát ezt az állapotmodellt indukálja.
  \item Harmadszor is mozgatva a tokent, elkezdhetjük a \emph{Link} tevékenységet.  
  \item Végül, az ábra jobb szélén látható nyílra helyezve a tokent, kifejezzük a második tevékenység befejeződését is.  
\end{itemize}   
\end{pelda}

Ha a folyamatot (például a fenti példához hasonlóan token mozgatásával) szimuláljuk, egy konkrét lefutását kapjuk. A folyamat konkrét lefutásait a folyamatmodell \fogalomragozva{folyamatpeldany}{folyamatpéldányainak} nevezzük. Ez nyilván akkor lesz izgalmas fogalom, ha egy folyamatot nem csak egyszer hajtunk végre, hanem többször,
Ha belegondolunk, a tokennel valójában a végrehajtás pillanatnyi állapotát jelöltük ki, és a következő állapotteret jártuk be vele: $\{$ még nem kezdődött el egyik tevékenység sem, \emph{Compile} folyamatban van, \emph{Compile} befejeződött és \emph{Link} még nem kezdődött el, \emph{Link} folyamatban van, befejeződött mindkét tevékenység $\}$. A folyamatmodell határozza meg ezt az öt állapotot, valamint hogy milyen állapotátmenetek megengedettek köztük (jelen esetben csak a felsorolás sorrendjében lehet állapotot váltani). A folyamatmodell tehát ezt az állapotmodellt indukálja, a folyamat szimulációját pedig visszavezettük a fent konstruált állapotmodell szimulációra. A szimuláció eredményeképpen \aref{fig:szintaxis/szekvencia-ido}. ábrán látható idődiagramhoz hasonló eredményt kapunk.
 \remofigscalefixed{szintaxis/szekvencia-ido}{Szekvencia időbeli lefutása}{\folyamatmodellscale}


\subsection{Folyamatpéldányok}
TODO legyen folyamat kezdete és vége

\begin{pelda}
Vegyük ismét példának \aref{fig:szintaxis/szekvencia}. ábrán látható folyamatmodellt, és szimuláljuk. Ahogy \aref{fig:szintaxis/szekvencia-ido}. ábra idődiagramja is mutatja, a szimuláció alatt sorban a következő események következtek be: \begin{enumerate}
  \item A \emph{Compile} tevékenység elkezdődik.
  \item A \emph{Compile} tevékenység befejeződik.
  \item A \emph{Link} tevékenység elkezdődik.
  \item A \emph{Link} tevékenység befejeződik.
\end{enumerate}
\end{pelda}


Ha egy folyamatmodellt szimulálunk (például a fent bemutatott manuális módszerrel, token mozgatásával), akkor a folyamat egy konkrét lefutását kapjuk. A folyamat konkrét lefutásait a folyamatmodell \fogalomragozva{folyamat-peldany}{folyamatpéldányainak} nevezzük. A folyamatpéldány tulajdonképpen események sorozata. Ezen események a folyamatot alkotó elemi tevékenységek kezdetét és befejezését jelzik, illetve az egész folyamat kezdetét és befejezését. A folyamatmodell voltaképp ezen eseményeket azonosítja, és lehetséges sorrendjükre tesz megkötéseket.

\begin{definicio}
	Egy folyamatmodellhez tartozó \fogalom{folyamat-peldany} olyan diszkrét eseménysor, amelyet a következő jellegű események alkotják, a folyamatmodell által megszabott időrendben: 	\begin{itemize}
	  \item a folyamat kezdete,
	  \item a folyamatot alkotó egyik tevékenység kezdete, 
	  \item a folyamatot alkotó egyik tevékenység vége, 
	  \item a folyamat vége.
	\end{itemize}
\end{definicio}

A folyamatmodellek és folyamatpéldányok közti viszony nyilván akkor lesz izgalmas, ha egy folyamatot nem csak egyszer hajtunk végre, hanem többször, egymás után vagy akár részben átlapolódva. Az egyszerre végrehajtott folyamatpéldányokat úgy lehet szimulálni, hogy minden folyamatpéldányhoz egy-egy tokent rendelünk, amelyik a példány pillanatnyi állapotát jellemzi; ezután az összes tokent felrakjuk a folyamat diagramjára, és külön-külön léptetgetjük őket.  \iflabeldef{cha:teljesitmenymodellezes}{\Aref{cha:teljesitmenymodellezes}.}{A \emph{Teljesítménymodellezés}} fejezetben kifejezetten azzal az esettel foglalkozunk majd, amikor ugyanaz a folyamat egyszerre nagyon sok példányban fut. Ilyen esetben a szimuláció során nem is érdemes a tokenekkel egyenként vesződni; csak azt tartjuk számon, hogy hány token tartózkodik éppen a diagram egy adott pontján.


\begin{definicio}
	\fogalom{elagazas}
\end{definicio}

\begin{definicio}
	\fogalom{orfeltetel}
\end{definicio}

\remofigscalefixed{szintaxis/elagazas}{Elágazás grafikus szintaxisa őrfeltételekkel}{\folyamatmodellscale}

Szemantika:

o Csak az egyik ág hajtódik végre

o Nemdeterminizmus lehetséges: átlapolódó őrfeltételek esetén vagy egyszerűen akkor, ha nincsenek őrfeltételek.


Szemantika:

o Nem meghatározott végrehajtási sorrend

o Párhuzamos / átlapolt végrehajtás is lehet

Részletesen a \szgarch tárgyban.

\begin{definicio}
	\fogalom{ciklus}
\end{definicio}

\remofigscalefixed{szintaxis/ciklus}{Ciklus grafikus szintaxisa}{\folyamatmodellscale}

\begin{definicio}
	\fogalom{fork}, \fogalom{join}
\end{definicio}

\remofigscalefixed{szintaxis/fork-join}{Fork és join}{\folyamatmodellscale}

\begin{definicio}
	\fogalom{flow-begin}, \fogalom{flow-end}
\end{definicio}

\remofigscalefixed{szintaxis/flow-begin-flow-end}{Flow begin és flow end grafikus szintaxisa}{\folyamatmodellscale}


\begin{definicio}
	\fogalom{hierarchia}
\end{definicio}

• Elemi lépés valójában alfolyamat

\remofigscalefixed{szintaxis/hierarchia}{Hierarchia grafikus szintaxisa}{\folyamatmodellscale}

\remofigscalefixed{szintaxis/hierarchia-ido}{Hierarchia időbeli lefutása}{\folyamatmodellscale}

\begin{definicio}
	\fogalom{hivas}
\end{definicio}


\remofigscalefixed{szintaxis/hivas}{Hívás grafikus szintaxisa}{\folyamatmodellscale}

\remofigscalefixed{szintaxis/hivas-ido}{Hívás időbeli lefutása}{\folyamatmodellscale}

Beágyazható a “főfolyamatba”, ha helyes a finomítás, azaz

• A lépések együtt ugyanazt állítják elő, mint a folyamat

• Nincs olyan eset, amit nem kezelünk a hívó fél szintjén

• (Input/output konzisztencia)


\fogalom{folyamatabra} (\fogalomangolul{folyamatabra})

\fogalom{dontesi-diagram} (\fogalomangolul{dontesi-diagram})



\fogalom{folyamatabra} (\fogalomangolul{folyamatabra})

\fogalom{vezerlesi-folyam}

\fogalom{komplexitas}

\fogalom{ciklomatikus-komplexitas}

\fogalom{rekurzio}



\section{Vezérlési folyamok folyamatmodelljei}



\subsection{Leképzés}

\begin{minipage}{\balhasab}
\begin{lstlisting}
<statement1>
<statement2>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-01}{\folyamatmodellscale}
\end{minipage}



\begin{minipage}{\balhasab}
\begin{lstlisting}
if (<expression>)
	<statement>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-02}{\folyamatmodellscale}
\end{minipage}



\begin{minipage}{\balhasab}
\begin{lstlisting}
if (<expression>)
	<statement1>
else
	<statement2>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-03}{\folyamatmodellscale}
\end{minipage}

\subsection{Összetett példa ábrázolása}

\begin{minipage}{\balhasab}
\begin{lstlisting}
while (<expression>)
	<statement>
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-04}{\folyamatmodellscale}
\end{minipage}



\begin{minipage}{\balhasab}
\begin{lstlisting}
do
	<statement>
while (<expression>)
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-05}{\folyamatmodellscale}
\end{minipage}



Nézzünk meg egy összetettebb példát!

\begin{minipage}{\balhasab}
\begin{lstlisting}
while (a != b) {
	if (a > b) {
		a = a - b;
	} else {
		b = b - a;
	}
}
return a;
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-06}{\folyamatmodellscale}
\end{minipage}

%\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-07}{\folyamatmodellscale}

Lépésenként átalakítva:

\begin{minipage}{0.2\linewidth}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-07}{\folyamatmodellscale}
\end{minipage}
\begin{minipage}{0.35\linewidth}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-08}{\folyamatmodellscale}
\end{minipage}
\begin{minipage}{0.45\linewidth}
	\simplefigscale{vezerlesi-folyamat/vezerlesi-folyamat-09}{\folyamatmodellscale}
\end{minipage}

\subsection{Komplexitás}

\begin{definicio}
\fogalom{ciklomatikus-komplexitas}: $M$ = $E$ - $N$ + 2, ahol ...
\end{definicio}

\remofigscale{vezerlesi-folyamat/ciklomatikus-komplexitas}{A ciklomatikus komplexitás fogalmai. $E$: élek (narancssárga), $N$ csomópontok (kék)}{\folyamatmodellscale}

\begin{megjegyzes}
	A ciklomatikus komplexitással a \szofttech tárgy is foglalkozik.
\end{megjegyzes}

\subsection{Példa: $n!$ meghatározása}

Vizsgáljuk meg az alábbi programkódot, ami egy szám faktoriálisát határozza meg!

\begin{lstlisting}
int fact(int n) {
	return (n == 0) ? 1 : n * fact(n - 1);
}
\end{lstlisting}

A \lstinline{?:} operátor tömör kódot eredményez, de esetünkben fontosabb szempont, hogy a kódban bejárható útvonalakat lássuk. Mentsük el továbbá a visszatérési értéket egy átmeneti változóba. Így az alábbi kódot kapjuk:

\begin{minipage}{\balhasab}
\begin{lstlisting}
int fact(int n) {
	int tmp1;
	if (n == 0) {
		tmp1 = 1;
	} else {
		int tmp2 = fact(n - 1);
		tmp1 = n * tmp2;
	}
	return tmp1;
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{faktorialis}{\folyamatmodellscale}
\end{minipage}

\subsection{Példa: $n \choose k$ meghatározása}

Az alábbi rekurzív függvény meghatározza $n \choose k$ értékét. A számításhoz felhasználjuk, hogy ${0 \choose 0} = 1$ és ${n \choose k} = {n-1 \choose k} + {n-1 \choose k-1}$.


\begin{minipage}{\balhasab}
\begin{lstlisting}
int choose(int n, int k) {
	if (k < 0 || k > n) {
		return 0;
	} else if (k == 0 && n == 0) {
		return 1;
	} else {
		int x = spawn choose(n - 1, k);
		int y = spawn choose(n - 1, k - 1);
		sync;
		return x + y;
	}
}
\end{lstlisting}
\end{minipage}
\begin{minipage}{\jobbhasab}
	\simplefigscale{n-alatt-a-k}{\folyamatmodellscale}
\end{minipage}



\section{Formalizmusok}

Az \rovidites{OMG} (\roviditesangolulkifejtve{OMG}) két szabványa:

\rovidites{UML}~\cite{UML} \fogalom{aktivitas-diagram} (\fogalomangolul{aktivitas-diagram})

\rovidites{BPMN}~\cite{omg2011bpmn}

%\fogalom{folyamatmodell} \fogalom{vegrehajthato-modell}




\section{Jólstrukturált folyamatok}\label{sec:jolstrukturalt-folyamatok}

A folyamatmodellek a tanultak szerint leírhatóak egy vezérlésifolyam-gráffal. Eddig azonban semmilyen megszorítást nem tettünk arra, hogy a vezérlési élek mely csomópontokat melyekkel köthetik össze; így pedig sok értelmetlen vagy helytelenül működő folyamatmodell építhető. Ráadásul az egyébként értelmes folyamatmodellek is gyakran átláthatatlanok, nehezen érthetőek lehetnek.

Ezért szokás a folyamatmodelleknek az alábbiakban definiált "biztonságos" részhalmazát elkülöníteni, amely megengedett blokkokból építkezik csak.

\begin{definicio}
	Egy \fogalom{reszfolyamat} akkor \fogalom{jolstrukturalt}, ha egyféleképpen kezdődik el és egyféleképpen fejeződik be; továbbá összetett (több elemből álló) részfolyamatok esetén annak alkotórészei hasonlóan jólstrukturáltak, és megengedett módon vannak összekapcsolva. Egy \fogalom{folyamat} akkor jólstrukturált, ha az egész ilyen módon épül fel.
\end{definicio}

\subsection{Jólstrukturált blokk}

A következő (egy belépési és egy kilépési pontú) részfolyamatokat tekintjük \fogalom{jolstrukturalt} blokknak (más néven jólstrukturált részfolyamatnak):

\begin{itemize}
\item egyetlen elemi tevékenység önmagában;
\item egyetlen folyamathivatkozás/hívás (máshol definiált folyamatmodell újrafelhasználása);
\item üres vezérlési élszakasz;
\item ,,soros kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok szekvenciája (egyszerű vezérlési éllel egymás után kötve őket);
\item ,,\emph{Fork-Join} kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok egy $n$ ágú \emph{Fork} és egy $n$ ágú \emph{Join} közé zárva;
\item ,,\emph{Decision-Merge} kapcsolás": a $P_1$, $P_2$, ..., $P_n$ jólstrukturált blokkok egy $n$ ágú \emph{Decision} és egy $n$ ágú \emph{Merge} közé zárva;
\item ,,Ciklus": egy kétágú \emph{Merge} csomóponttal kezdődik, amely után a jólstrukturált $P_1$ blokkok következik, majd egy kétágú \emph{Decision}, melynek egyik ága a részfolyamat vége, a másik a $P_2$ jólstrukturált blokkokon keresztül az előbbi \emph{Merge}-be tér vissza.
\end{itemize}

\subsection{Jólstrukturált folyamatmodell}

Egy teljes folyamatmodell jólstrukturált, ha egyetlen belépési pontja (\emph{Flow begin}) és kilépési pontja (\emph{Flow end}) egy jólstrukturált blokkot zár közre.

Amint az a definícióból látszik, egy teljes folyamat lehet úgy jólstrukturált, hogy pl. egy egyszerű elemi tevékenység, egy fork-join blokk és egy ciklus szekvenciájából áll, de csak ha a fork-join blokk és a ciklus maga is kisebb jólstrukturált blokkokból van felépítve.

A jólstrukturáltság célja, hogy áttekinthetőbbé tegye a folyamatot, és hogy bizonyos hibalehetőségeket (pl. holtpont) eleve kizárjon. A folyamatmodellekre jellemző hibamintákról később lesz szó; ezek egy jó része jólstrukturált modellnél elő sem fordulhat. Ha a folyamat nem jólstrukturált, akkor külön ellenőrzési eljárásokkal kell kizárni a hibalehetőségeket. Mindemellett nem csak a jólstrukturált folyamatmodellek lehetnek értelmesek; előadáson volt példa nem jólstrukturált, de értelmes folyamatra (ld. ,,Jólstrukturált folyamatok'' c. dia, vagy a gyártósoros példához tartozó ,,Együttes nézet'' c. dia).

Léteznek olyan folyamatmodellezési nyelvek is, amelyek nem engedik tetszőleges gráfként megalkotni a vezérlési folyamot, hanem kizárólag jólstrukturált blokkokat lehet létrehozni és más jólstrukturált blokkokból felépíteni. Ilyen nyelv pl. a \rovidites{BPMN} (alap jelkészlete), vagy a programozásoktatásból ismerős Nassi-Shneiderman-féle \fogalom{struktogram}. Ezeken a nyelveken a megkötések miatt bizonyos folyamatokat csak körülményesebben lehet megfogalmazni; cserébe az adott nyelven készített összes folyamatról külön ellenőrzés nélkül tudható, hogy rendelkezik a jólstrukturáltság fent tárgyalt összes előnyével.

A tanultak szerint az imperatív programnyelvek vezérlésifolyam-gráfja is folyamatmodell; mit jelent a programokra nézve a jólstrukturáltság? A program vezérlési folyamja akkor lesz jólstrukturált, ha egy belépési és egy kilépési pontja van, és egyszerű utasításokból szekvenciális egymás után fűzéssel áll össze, ill. elágazásokat vagy ciklusokat tartalmaz (ill. megfelelő programozási nyelv/platform esetén akár párhuzamosan végrehajtott blokkokat). A \lstinline{goto}, idő előtti \lstinline{return} és hasonló jellegű ugrások azonban túlmutatnak a jólstrukturáltságon \todo{Ezt így nem biztos, hogy érthető lesz. Ötlet: "kivezetnek a jólstrukturált modellek közül". Én beleírnám, hogy a "break" parancs is ilyen. Egyébként a "return" gyakran kifejezetten átláthatóbbá teszi a kódot (az indentáció csökkentésével), ezt is beleszőhetjük lábjegyzetbe.}; ennek megfelelően könnyen átláthatatlanná tehetik a forráskódot, így mértékletes alkalmazásukat szokták javasolni, lehetőség szerint kerülendők.

\section{Adatfolyamhálók}

\fogalom{adatfolyam} \rovidites{DFN}

\fogalom{tevekenyseg}

\fogalom{folyamatmotor} (\fogalomangolul{folyamatmotor})

\newcommand{\prioritas}{\pi}
\newcommand{\tuple}[1]{\langle #1 \rangle}

tüzelések: $\tuple{s_0; \mathrm{in} = c_0; s_1; \mathrm{out} = c_2; \prioritas}$

adatfolyam csomópont: $n = (I_n, O_n, S_n, s_n^0, R_n, M_n)$

\section{Kitekintés\kieg}


\rovidites{PERT} (nem tud elágazást ábrázolni)

\subsection{Szabványok}

\rovidites{BPEL}

\subsection{Technológiák}

\subsubsection{Adatelemzés}

Az Airbnb cég Airflow eszköze\footnote{\url{https://github.com/airbnb/airflow}} adatelemzési folyamatok definiálására és végrehajtására alkalmas.

Több olyan rendszer is létezik, amelyek tudományos folyamatok futtatását teszik lehetővé (\emph{scientific workflow engine}), beleértve az adatok összegyűjtését, elemzését és vizualizálását. Ilyen rendszerek például a
Kepler\footnote{\url{https://kepler-project.org/}} és a Taverna\footnote{\url{http://taverna.incubator.apache.org/}}.

\subsubsection{Üzleti folyamatmodellek}

Az üzleti folyamatok modellezésére használt szoftverek manapság tipikusan a BPMN 2.0 szabványt valósítják meg.\footnote{\url{https://en.wikipedia.org/wiki/List_of_BPMN_2.0_engines}}

Ilyen eszközök pédául a jBPM\footnote{\url{http://www.jbpm.org/}}, a Bonita BPM\footnote{\url{http://www.bonitasoft.com/}}, Camunda\footnote{\url{https://camunda.org/}} és az Eclipse Stardust\footnote{\url{https://www.eclipse.org/stardust/}}.
